Писать коментарии в jsconfig нельзя
   Технология IntelliSense анализирует по умолчанию все файлы. 
   т.к. vscode тоже от Microsoft они предусмотрели файл jsconfig.json.
   есть ещё tsconfig.json

   для настроек.
    exclude: [] - принимает исключения
    include: [] - явное подключение

    compilerOptions - принимает некоторые опции для настройки поведения проекта
    paths {} значение это путей, которые можно указывать в проекте в виде ключа 
Императивный подход - это когда один функционал вызывает другой функционал для выполнения
    какого-то своего действия, но берёт из глобально пространства 
Декларотивный подход - это когда в функцию передаёться другая функция из глобального 
    пространства в качестве параметра, используется там и возвращаеться новая функция
    с новым поведением.Такие функции называються функциями высокого порядка.
            

Пагинация - это постраничный вывод. Сервер не может выдать всё и сразу поэтому он выдаёт порциями.
/*
    Клиентская часть может быть без бэкенда если не трубеться обмен данными
*/

*Что бы равномерно поделить данные на страницу нужно кол-во данных / на кол-во отображаемых

файл cookie по сути текстовый файл, он передаёться при каждом обращении к серверу
туда-обратно
Сервер не хранит cookie, этот файл на клиенте. Файл куки может быть забит информацией.
Хоть его размер не значительный в 4кб, но если идёт постоянный обменн данными с серветом,
то это тратит трафик, даже если мы делаем незначительынй запрос этот файл наполненый информацией гоняеться
туда сюда, поэтому делают так:
Каждый домен имеет свой cookie. Можно сайт разделить на несколько доменов. 
Делая очередной незначительный запрос на тот домен, на котором cookie не забиты, можно экономить трафик

Предположим в cookie храним id пользователя по которому определяем его. Из-за того что cookie можно
в ручную исправить и перезагрузить страницу мы бы могли получить данные другова пользователя, но 
такой момент учитывают и данные шифруют
REST - REpresentational State Transfer - архитектура передачи данных клиент-сервер
HTTP - это данные которые передаються в открытом виде по WI-FI. Такие данные можно переловить
и воспользоваться куками от чужого имени. Сайты для этого отслеживают IP и геолокацию,
для того что бы определить пользователя.
Что бы перехваченные данные не раскрыли используют HTTPS протокол. На сервере устанавливаеться
SLL сертификат, который кодирует эти данные переданые по воздуху. Даже если их украдут их придёться 
раскодировать.
Как это работает. При запросе на сервер, сервер отсылает браузеру ключ декодирования данных
    только тогда происходит общения сервера с клиентом. Это работает на момент сессии

SSH (Secure Shell — "безопасная оболочка") - это протокол безопасного подключения к серверу и его управлением.
    доступ осуществляется к терминалу(консоли) через ssh клиент. Возможно управлять удалённо файловыми системами, 
    пробрасывать порты. Такой клиент стандартно стоит на linux Ubuntu

Socket - (СОКЕТ) это соединение (открытие канала) клиента с сервером которое устанавливаеться один раз и обмен данными совершаеться
         практически мгновенно. В то время как любые запросы GET POST PUT DELETE ... посылаются на сервер, что-то
         обрабатываеться и сервер подготавливает ответ.
         Прокт на Node.JS WebSocket как было прочитано без настроек держит 5к одновременных подключений

express - фреймворк

Proxy сервер - это дополнительная прослока между клиентом и сетью интернет. При обычных обстоятельствах
               клиент посылает запросы со своего ip на посещаемые сайты и получает ответ. Какое-то кол-во
               ip адресов могут иметь ограничение к сайтам которые устанавливает провайдер,
               поэтому запросы будут блокироваться. И на помощь приходит такая прослойка как Proxy,
               через которую мы делаем запросы и от её имени делаються запросы на те сайты куда мы пытаемся попасть.
               На Proxy клиенте мы можем выбирать страны и ip которые и будут светиться.
               Так же proxy может подменять версию браузера, версию OS вообщем всё что бы скрыть клиента.
            Но не вс proxy подмениваю ip. Это прозрачные proxy. Подменяют всё но не ip.
            Скрытые proxy, скрывать могут всё.
    Есть публичные Proxy - выложенные в сети ip адреса с портом. Обычно это помойка где половина не работает,
                    а если работает, то через этот proxy творят магию и уходят 
    Пакетные Proxy - программы которые разработаны для обычного клиента для удобства пользования
    Совместные - это по договоренности не больше определённого круга лиц. Конечно платно
    Индивидуальные - это или свой собирать сервер и настраивать имея логин и пароль им пользоваться 
                     или через котого, но индивидуально и платно

VPN - это та же прослойка как и proxy, но уже данные по сети шифруються
IP - Что бы можно было в интернете понимать кто есть кто, каждое устройство имеет ip адрес. Адрес это как домен
     вид адреса v4 000.000.000.000 - 255.255.255.255. Таких комбинаций может быть 4 228 250 625. 
     Для сравнения на земле по данным 7 763 035 303 населения. Какая то часть не имеет интернета.
     Так же у человека может быть не одно устройство и чаще всего ставят роутер. Выход в интернет 
     осуществляеться с одного адреса. У роутера своя локальная сеть так же состоящая из v4 ip адресов
     по которой он определяет запрос. 

     v6 выглядит примерно так 2001:0DB8:3C4D:7777:0260:3EFF:FE15:9501 /64

4 Принципа ООП
Интерполяция строк - это обычная подстановка в строку какойго то изменяющегося куска строки, но в кусок 
                    html. Обычно это происходит через шаблонизаторы или библиотеки которые дают такую возможность
                    и используеться синтаксис {{переменная в html}}.
Конкатенация - это соединение строк. Через JS `текст ${переменная}` или "Мой" + " текст" 

Полиморфизм - это возможность использовать на разных уровнях кода одну и ту же переменную, но с разным значением. 
    Пример одного и того же метода:
        class Human {
            constructor(name) {
                this.name = name;
            }
            say() {
                return `Hello, my name is ${this.name}, I like travelling`;
            }
        }

        class Men extends Human {
            constructor(name) {
                super(name)
            }
            // Берем метод say у родителя.
        }

        class Coder extends Human {
            constructor(name) {
                super(name)
            }
            say() {
                // Переопределяем метод родителя say для отображения нового значения.
                return `Hello, my name is ${this.name}, I like coding`;
            }
        }

        const alex = new Men('Alex');
        const leo = new Coder('Leo');
            //вроде бы один и тот же метод, но на самом деле класс Coder обзавёлся своим. 
            По сути это не апгрейд старого метода, а лишь закос под метод с написанием нового функционала.
        alex.say() // "Hello, my name is Alex, I like travelling"
        leo.say() // "Hello, my name is Leo, I like coding"