# Файл docker-compose должен начинаться с тега версии.
#  Существует несколько файлов docker-compose: docker-compose.yml docker-compose.admin.yml docker-compose.override.yml
#  отличия в приоритете. Если запускать 2 файла и если у них есть одинаковые сервисы то приоритет перезапишет существующие
#   команды.
# 1. docker-compose так же подтягивает image
# 2. сервисы могут содержать или build указывающий на файл Dockerfile или image указывающий сразу на образ
# 3. имя сервиса автоматически становиться --network-alias для контейнера


version: "3"

# docker-composes работает с сервисами.1 сервис = 1 контейнер. Сервисом может быть клиент, сервер, сервер баз данных...
# Раздел, в котором будут описаны сервисы, начинается с 'services'.
# 
services:

  # что бы создать клиентское и серверное приложения. нам нужно два сервиса.
  # Сервис назвать можно как угодно разработчику. Назвали сервис 'server'.
  server:
  
    # Ключевое слово "build" позволяет задать путь к файлу Dockerfile для создания образа,
    # Здесь 'server/' соответствует пути к папке сервера, которая содержит Dockerfile.
    build: server/

    # более подробная настройка положения Dockerfile
    build:
      context: .
      dockerfile: Dockerfile

    # Команда, которую нужно запустить после создания образа.
    command: node ./index.js

    # 
    restart: always

    # В 'server/index.js' указан порт 3000. Обратиться к серверу в контейнере с нашего компьютера 
    # мы должны организовать перенаправление этого порта на порт компьютера.
    # При его использовании применяется следующая конструкция: [порт компьютера]:[порт контейнера]
    ports:
      - 3000:3000

  # Этот сервис(контейнер) назван 'client'.
  client:

    # 'client/ путь к папке, которая содержит Dockerfile
    build: client/

    # Команда, которую нужно запустить после создания образа.  gulp
    command: gulp или sh -c "npm install && cd /home/app/server && npm run dev"

    # используется для описания типа сети.Тут мы указываем то, что контейнер может обращаться к 'localhost' компьютера.
    # По умолчанию контейнера связаны сетью bridge, так что в основном не link не network указывать не надо.
    network_mode: host

    # должен ли сервис,прежде чем запуститься, ждать, когда будут готовы к работе другие сервисы.
    # Нам нужно, чтобы сервис 'client' дождался бы готовности к работе сервиса 'server'.
    depends_on:
      - server
    
  
    # Установка переменных окружения в файле compose напрямую. Приоритет выше чем подключённый файл
    environment: 
      - DEBUG=1  # Передача переменных на прямую
      DEBUG2: 1  # так тож можно. Аналог при запуске -e DEBUG2=1. 
    # compose автоматически смотрит в файл .env (только в него) поэтому можно обращаться к переменным так:
      PORT: ${NODE_PORT}
    env_file: # можно передать целый файл или этот файл подключить при запуске --env-file ./config/.env.dev
      - .env.dev
    # Файлов переменных окружения может быть несколько .env.ci, .env.dev, .env.prod видимо их можно придумывать
    # подключая через env_file  docker переносит их в environment и при запуске сервисов передаёт в контейнер.
    # Можно посмотреть через docker-compose config 
    container_name: ${SERVER_NAME}  # так можно использовать в compose переменные .env файла. кстате критической ошибки не будет если
                                    # применять не в важном месте и забыть передать. Конечно если не передать в 
                                    # важных местах image: nginx:${NGINX_VERSION}-alpine проект не запуститься
                                    # Кстате свойство container_name не применяется если используется docker-compose run  
    # Пробовать использовать переменные подключенного файла так ${SERVER_NAME} нет смысла. Так работает только с.env файлом. 

# Можно повторно использовать конфигурацию сервиса.
# К примеру у нас в другом файле уже описан сервис. Мы конечно можем скопировать, но если нужно внести изменения,
# для обоих случаев, при придётся так же править 2 файла. Так что можно просто сослаться на сервис webapp для сервиса web
# указанный дальше environment будет переопределять. 
services:
  web:
    extends:
      file: common-services.yml
      service: webapp
    environment:
      - DEBUG=1
# Если требуется ссылаться на сервис в текущем файле достаточно указать 
  web1:
    extends: web
    # с осторожностью использовать данные параметры т.к. контейнер может работать только хуже если указать неправильно
    cpu_shares: 5
    cpuset: 4       # Использовать кол-во cpu контейнером. 0-3 (диапазон от 1 до 4 проца). 1,3 (2й и 4й) 
    cpus: "1.5"     # Использует 1.5 процессора. аналог cpu_quota: "150000"
    
# Возможные настройки
  db:
    image: mysql:latest
    volumes: 
      - todo-mysql-data:/var/lib/mysql
    
    

    networks:
      - overlay

  # В compose именованный том не создаётся автоматически как при обычном cli Где достаточно указать флаг -v. Здесь
  # нужно указывать создание тома на верхнем уровне где и services с именем тома на борту. К созданию сети так же это относиться
volumes:
  todo-mysql-data:

networks:
  overlay: 

  node:
    image: node:latest
    stdin_open: true # docker run -i
    tty: true  # docker run -t
    working_dir: /app  # Если задать папку то при обращении к контейнеру мы так же попадём в неё а не в корень. работает 
                       # не атк как в Dockerfile в котором можно указать директорию и файл строить относительно её. тут 
                       # придётся всё равно везде указать путь /app 


  app: #набор не очень полезных команд

    deploy: # Какая-то возможность поставить просто метку для сервиса. Если labels использовать без deploy, то метка будет на контейнере 
      labels:
        com.example.description: "This label will appear on the web service"
        mode: global # хз что за штука. Ещё режим replicated есть
      placement:
        constraints: # ограничения. Список примеров ограничений.
          - "node.id==2ivku8v2gvtg4"
          - "node.hostname!=node-2"
          - "node.role==manager"
          - "node.labels.security==high"
          - "node.platform.os==windows"
          - "node.platform.arch==x86_64"
          - "engine.labels.operatingsystem==ubuntu 18.04"
        preferences:
          - spread: node.labels.zone

# #######------<{ docker-compose команды }>------########


# docker-compose 
#    build                            Собрать images, если файл compose использует build
#    up                               Запустить. -d(--detach)
#    down                             Остановить 
#    logs -f [service name]           Журнал сервисов 
#    ps                               список контейнеров
#    exec [service name] [command]    позволяет выполнить команду в выполняющемся контейнере
#    images                           вывести список образов
#    ...
#    run                Позволяет запускать отдельные сервисы.
#                       Запустив композер с командой run внутри его проставленные порты не будут 
#                       отрабатывать. Придётся или их утверждать дополнительным флагом --service-ports или указывать -p с портами 
#                         docker-compose run db bash   - запускает подсоединившись к контейнеру
#                         docker-compose -f docker-compose.yml -f docker-compose.admin.yml run backup_db  - запуск нескольких файлов
#  flags:
#    -p имяПроекта - по умолчанию имя проекта имя папки


