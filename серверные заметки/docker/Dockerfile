# В командах где требуеться указывать путь, не стоит указывать таким образом: /папка
# дорер начнёт с корня диска рекурсивно проходиться по папкам.
# 1. Через Dockerfile нет возможности передать локальное volume, можно только привязать папку в контейнере к именованому хранилищу 
#    имя которого создаёться автоматически 
# 2. Имя будущего images так же нет возможности задать в Dockerfile, можно при использовании docker build 
# 3. Если использовать docker-compose run "имя сервиса", в сервисе котором подключён через build Dockerfile,
#    то проект будет создаваться не успев забилдиться. Вариант не использовать отдельный сервис, а запустить docker-compose up --build
#    или создать отдельно build через dicker run и включить его потом в compose в качестве image
# 4. Dockerfile не знает о .env и использоваться как в docker-compose синтаксис ${} не может
FROM ОБРАЗ  
# Этап сборки в таком случае просто имеет номер. Можно задать имя
FROM ОБРАЗ AS builder 
# Имя потребется если в одном DockerFile описано несколько сборок FROM со своими RUN,COPY и т.д.
# командами. Это многоэтапные сборки. Запуская этот файл можно выполнить сборку конкретного этапа указав
# docker build --target builder -t singlebw/my-first-image:latest .

RUN <команда консоли shell> или ["bash", "агрумент1", "агрумент2"]   
# Используеться при сборке imagse
# НЕ РЕКОМЕНДУЕТЬСЯ устанавливать много RUN команд т.к. каждая команда это следующий шаг построения проекта (называют слоем)
# и создавая что либо в одном шаге не получиться что либо убалить на слебующем шаге из предыдущего шага из-за этого размер image 
# растёт. Лучше всего выполнять команды в одном RUN используя && 
RUN apt install npm -y \ 
          && npm i пакет
# \ используеться что бы экрнировать скрытый символ перевода на новую строку если мы при этом хотим писать на следующей 
# строке а не в одну. -y лучше ставить что бы не было ошибки в docker из-за показывающих вопросов в процессе установки пакетов.

CMD <команда консоли shell> или ["bash", "агрумент1", "агрумент2"]
# CMD не включаеться как шаг построения проекта
# Записываеться в недра images. Когда будет стартовать images будет отрабатывать
# этот код. Выполняеться только последний CMD, так что смысла плодить нет.
# Я не видел результата выполнения данной команды когда пытался запускать контейнер и одновременно заходить
# docker run -it nameCon bash. Что бы увидеть результат нужно 
# Кстате если на пакете Node не указать CMD [ "bash" ] или при запуске то попадём сразу в node пространство а не в контейнер

ENTRYPOINT [ "bash" ]
# Обычно запуская контейнер с передачей аргументов мы указываем docker run -it bash "команда"
# Так вот можно запускать docker run -it "команда" если указан ENTRYPOINT

ENV MYSQL_ROOT_PASSWORD=secret
# Передать переменную окружения

ARG PEREM=latest  
# Можно обявить переменную а потом её использовать примерно так FROM base:${PEREM}
# Переменные можно использовать так: $PEREM или ${PEREM}. 2й вариант может так ${PEREM}_item

VOLUME [ "/folder1",  "/folder2" ]
# 

WORKDIR /virtualProject
# Команда WORKDIR создаст в контейнере по указанному пути папку. Далее в Dockerfile указывая ADD, VOLUME, COPY
# в контейнере будет ориентироваться относительно этой папки указывая "./"

ADD /db/conf* ./folder_test/config/
# Запуская Dockerfile консоль всегда на его уровне. Мы может писать хоть path/folder || /path/folder || ./path/folder 
# т.к. указан WORKDIR то все файлы с локальной манины попадут на виртуальную /virtualProject/folder_test/config/
# Если нам надо кинуть в сразу в относительную папку, можно "./" писать как "." 
# ADD https://github.com/bessarabov/Moment/archive/1.3.1.tar.gz /app/     или    ADD 1.3.1.tar.gz /app/   может развернуть архив

COPY app ./
# COPY такой же как ADD, но урезанный. Не может вроде качать с URL. Не уверен но говорят что 2й аргумент должен иметь 
# закрывающий слешь COPY app/ ./prokect/app1/  а то могут быть проблемы
# COPY . .  Если утсновлен WORKDIR то копирование будет из текущего каталога где лежит Dockerfile в рабочий каталог 
# Если я правильно понял, то можно несколько фалов копировать COPY file1.js file2.js ./   
# Кстате копировать данные можно и из других контейнеров 
COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf

EXPOSE 3000
# EXPOSE говорящая клиенту на каком порту будет запускаться пакет в контейнере