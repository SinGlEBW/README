# Кнт: main
worker_processes 1;                    # Кол-во рабочих процессов. Лучше ставить auto
worker_cpu_affinity --                 # не нужный парраметр. значение указывать в битах что бы Привязать рабочие процессы к группам процессоров
worker_priority 0;                     # задаёт приоритет процессам nginx на фоне процессов в Linux. от -20 до 20 Чем меньше тем выше приоритет. 
working_directory --;                  # Задаёт рабочий каталог.
worker_rlimit_core --;                 # Ограничивает  размер core-файла
worker_rlimit_nofile --;               # Ограничивает максимальное число открытых файлов. Как-то связанно с worker_connections.
                                       # каждый клиент открывает как минимум 2 файла запорс и ответ. хз
worker_shutdown_timeout --;            # Задаёт таймаут в секундах для плавного завершения рабочих процессов.
worker_aio_requests                    # Если включён aio on; и use epoll;, то задаёт максимальное число ожидающих обработки операций асинхронного 
                                       # ввода-вывода для одного рабочего процесса.
thread_pool default                    # Как я понял если включён многопоточный режим --with-thread и включён aio threads; (по ум. он off)
            threads=32                 # т.к. nginx работает в 1 процессе, можно указать Имя для группы потоков в этом процессе, число потоков
            max_queue=65536;           # и если все потоки заняты можно задать максимальное число задач которые будут ждать освобожнения потоков в очереди.     
# Серверы(не Nginx) выделяют на каждый запрос отдельный поток.NGINX обработку множества соединений и запросов в одном рабочем процессе
# Для этого применяются сокеты в неблокирующем режиме и такие эффективные методы работы с событиями, как epoll и kqueue.                                    
# Рабочий процесс получает события из ядра и обрабатывает их

# Для асинхронного(параллельного) чтения в Linux требуется установка флага O_DIRECT на файловом дескрипторе. Это означает, 
# timeout время ожидания. Есть потоки которые стоят в очереди и есть timeout в течении которых храниться подключившиеся клиенты,  


master_process on;                     # директива предназначена для разработчиков nginx


daemon                                 # режим демона. хз
debug_points abort | stop;             # При использовании error_log префикса debug или debug_connection если возникнет ошибка
                                       # то stop остановит на этапе сбоя, abort - куда-то там запишет в файл
ssl_engine                             # НЕ ЯСНО. Задаёт название аппаратного SSL-акселератора
timer_resolution --                    # Рекомендуют 100ms. По ум. gettimeofday() вызывается после каждой операции получения событий из ядра. хз
                                       # а так будет через 100ms вызываться.

pid logs/nginx.pid;                    # файл, в котором будет храниться номер (PID) главного процесса. хз зачем если в top он есть
lock_file logs/nginx.lock              # подключает файлы каких то блокировок для accept_mutex
load_module                            # Загружает динамические модули: modules/имя_модуля.so
pcre_jit off;                          # Ускоряет работу рег.выражений. Требуеться собрать nginx --with-pcre-jit 
                                       # --with-pcre=библиотека PCRE версии 8.20 



       
                                       
env TZ=Europe/Moscow;                  # timeZone время сервера. Остальные переменные свои
user Пользователь Группа;              # Имя пользователя и Группа с правами которого будут работать рабочие процессы. Если не задано
                                       # имя берёться из системы.

# Кнт: main, http, mail, stream, server, location
error_log путь/error.log info;         # по ум. error префиксы. debug - что бы работал nginx собрать с --with-debug., info, notice, warn, error, crit, alert или emerg 
                                       # тогда в error_log будет писаться любое взаимодействие со страницей 90% непонятных данных.  
include                                # Включает в конфигурацию другой файл или файлы,





http{
  
  include       /etc/nginx/mime.types;   # nginx предусмотрел отдельный файл для хранения mime типов.
  types {                                # обычно файл уже заполнен нужными типами и сайт отображаеться нормально
      text/html  html;                   # в файле указываеться директива с типами
      image/gif  gif;
      image/jpeg jpg;
  }
}

events{
  use --;                          # Метод обработки. epol для linux. Есть (select, poll) - требуют модули, kqueue для [FreeBSD, macOS], /dev/poll, eventport.
  worker_connections 512;          # Как много хотим обработать одновременных соединений одним процессором.  Соединение считаеься:
                                   # клиент с сервером и сервер с проксирукмым сервером тож считаеться. Как понимаю  
                                   # имееться в виду socket соединение, т.к. http закрываеться при запросе ответе.
                                   # предлагают ставить 1024. Так же не может превышать worker_rlimit_nofile если он установлен.
  accept_mutex off;                 #"on" - рабочие процессы принимают новые соединения по очереди
                                    #"off" - о новых соединениях сообщается сразу всем рабочим процессам, но при низкой
                                    # интенсивности запросов процессоры оповещаються, а работаты хватит не всем и работают они в холостую
  accept_mutex_delay 500ms;        # Когда "accept_mutex on" запросы по очереди активируют процессы. Как только один из процессов освобождается
                                   # и пока другие нагружены этот свободный процесс готов принимать запросы пока истекает это время после уходит 
                                   # в сон дабы не грузить процессор, появиться новый запрос разбудит.
  
  multi_accept off;                # off рабочий процесс за один раз будет принимать только одно новое соединение.Равномерно распределяет нагрузку.
                                   # on  раб. процесс за один раз пытается выполнять много соединений. Хорошо если оочень много соединений.
  use

  debug_connection 172.18.0.1;     # Можно не указывать в error_log префикс debug, можно указать тут ip клиента
                                   # при присоединении которого в error_log добавиться киллометр ненужной инфы
  


};













# netstat -anlp