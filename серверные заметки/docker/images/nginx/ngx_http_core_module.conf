
  # Всё что не понятно описано внизу. 
  # Контекст(Ктх):	main, http, mail, stream, server, location  - там где может использоваться параметр. 
  #                 Ближе к location имеет выше приоритет и перезаписывает предыдущий даже если он имел аргументы.


server {
  listen 80 default_server;                       # можно слушать ip:port. Пример:  192.168.1.1:80; Слушать можно несколько listen
  server_name  www.domain.com domain.ru "";       # возможные домены. по ум. "". если запрос без загл. Host ставим "".
                                                  # Можно рег.выр.  ~^(?<user>.+)\.example\.net$  или маску *.example.org;
                                                  # Приор.: точное имя, длинное имя с маской в начале, с маской в конце, подходящие рег.выр.
                                                  # nginx не проверяет server_name если директива server единственная для данного порта 

  return 444;                                     # спец. команда закрывающая соединение nginx(страница не доступна).
                                                  # Вообще return может быть в location и возвращать любые HTML ошибки.
  location /test {
    return 404 'Страницы нет';                    # если в main установлено default_type application/octet-stream; то не отработает т.к. страница 
  };                                              # тип application/octet-stream; открывает окно для скачки.
 

  access_log path/access.log;                     # логи работы сайта. по ум. все логи  /var/log/nginx .Ктх:	main, http, mail, stream, server, location
  error_log  path/error.log debug;                # Можно сохранить в буфере памяти error_log memory:32m debug; а не в файле


# / подходит под любой запрос, но поиск осуществляеться в главном каталоге где сидит index.html.
# отработает: domain.ru/test.html если файл test.html рядом с index или если есть каталог test в котором test.html - domain.ru/test/test.html
# при чём директива index для 2го случая. 1й случай без разницы запрашиваем domain.ru/test.html или domain.ru/test1.html. index директива не влияет
# Отработает location / {} для test.html ещё в том случае если не добавлен location /test {} который возмёт смелость думать, запрашиваеться директива это или файл. 
  location / {                                                                                
    index          index.html index.php;         # файл по ум. nginx автоматом убирает его из URI. 
    include        /etc/nginx/conf.d/*.conf || fastcgi_params;    # Подключение внешнего файла или спец. параметра

    alias          /usr/share/nginx/html/img;    # складывает alias с запрашиваемым файлом без location вместо root + location                                                      
    expires 30d;                                 # истекает через 30 дней. Возможно это связанно с кешем.
    # Заголовок ответа
    add_header Host $host;                       # $host. Оказываеться не имеет отношения к server_name. Укажет реальный host.
    add_header Host $date_local;                 # Thursday, 11-Mar-2021 14:43:13 UTC 

  }
  # Через try_files можно обработать 404 ошибку, придёться в каждый location её ставить. Выбирает только один вариант развития событий.

  location = /img {
    try_files /img/1.jpg /img/2.jpg /img/3.jpg =404;    # на запрос domain.ru/img перебирает массив подставляя путь 
    root /var/share/nginx/html;                         # (alias | root) + try_files путь.  Если  файл есть останавливатся и отдаёт.
  }                                                     # Не важно какой route. root с location тут не складываеться если мы не берём информацию из.
                                                        # переменных. Пример: 
   location /test;                                      # запрос domain.ru/test   директива try_files подставит $uri/index.html ($uri = запросу после домена, а не location)
    try_files $uri/index.html $uri/index.php =404;      # /var/share/nginx/html/test/index.html тут уже root + $uri +  try_files[]
    root /var/share/nginx/html;                         # запрос: domain.ru/test/ так же прокатывает хотя путь получаеться
  }                                                     # /var/share/nginx/html/test//index.html
}


# Кнт: http, server, location, if в location

error_page 500 502 503 504 /50x.html; 
           404 =200 /404.html;                  # Если сервер расчитывает вернуть 404 ошибку, вернём 200 с указанием такого URI
                                                # Если на странице есть css подключение, то хоть и 200 код он всё равно не загрузит
                                                # т.к. uri не будет соответствовать. Такой вариант для html с внутренним css 
           404 = /404.php                       # тут вариант для proxy_pass, fastgci и т.д. = ,без кода, означает ворачивает тот же 404 код.



location / {
    error_page 404 = @fallback;     # Просто именованный location @fallback можно указать /404.html вместо имени
}

location @fallback {                # тут нельзя использовать alias
    proxy_pass http://backend;      
}
# -----------------------------------------------------------------------------------------------------
# ######--------<{ о буферах }>----------########
# Ограничение размера передаваемых данных:
#   тела запроса + заголовки, заголовки.
# Кнт:	http, server 
client_header_buffer_size 1k;       # размер буфера для заголовков, cookie и тела запроса. Если это всё не поместиться 
                                    # в это ограничение, то дополнительно подключается резерв large_client_header_buffers

large_client_header_buffers 4 8k;   # Резерв подключается добавляя недостающую память директиве client_header_buffer_size.
                                    # 1й параметр кол-во буферов, воспринимать как множитель для 2го параметра.
                                    # Если размер заголовков, cookie и тела запроса выйдет и за этот предел, то получим ошибку 400 (Bad Request)
                                    # Мим. значение что можно поставить это 512 байт.
# Кнт: http, server, location
client_body_buffer_size 8k;         # Помимо того что тело запроса 100% входит в ограничения предыдущих буферов, так у него ещё и своё ограничение есть. 
                                    # Если тело POST запроса превысит это ограничение, то ничего страшного не произойдёт, nginx вместо оперативной памяти
                                    # начнёт сохранять в /var/cache/nginx/client_temp временные файлы и удалять после отправки ответа. 
                                      
client_max_body_size  1m            # Максимальный размер тела (POST) запроса, то есть целый объект со всеми своими символами 
                                    # в Request Payload сколько то весит:  {text: "Абра-кадабра"} 
                                    # Вот превысив данное ограничение получим 413 (Request Entity Too Large)
                                    # Установив в 0 отключаем проверку размера тела POST запроса

# -----------------------------------------------------------------------------------------------------
# ######--------<{ Перенаправление - Redirect }>----------########
# Кнт: http, server, location
absolute_redirect on;       # off - относительное, on - абсолютное перенаправления
server_name_in_redirect off;# передать server_name в абсолютных перенаправлениях? Если нет имя берёт из Host, накрайняк  IP сервера.
port_in_redirect on;        # передать порт в абсолютных перенаправлениях?

# -----------------------------------------------------------------------------------------------------
# ######--------<{ Асинхронная(параллельная) работа workers }>----------########
# Требуеться если большая посещаемость и есть вероятность что запросовы блокируют другие запросы
# то есть встречается большое кол-во одновременных запросов клиентов, ядро отдано клиенту и выполняет его заапрос 
# ожидая результат, этого можно избежатью




# -----------------------------------------------------------------------------------------------------
# ######--------<{ Асинхронная(параллельная) работа с файлами }>----------########
# Требуется для сайта который принимает много входящих исходящих файлов.

# Файловый дескриптор - это некий id файла. При открытии файла os нумерует его для ядра. 
#                       Открыли 100 файлов — где-то в ядре появились 100 записей, 
#                       представленных целыми числами.

# Если я правильно понял то обычно при запросе файла, на сервере отправка проходит в несколько этапов. Функции взял из php, но там возможно из с++,
# fopen();      открывает запрошенный файл и новый файл для записи с соответствующими ключами 
# fread();      данные запрошенного файла записывает в буфер
# fwrite();     данные из буфера записывает в новый для отправки файл
# fclose();     оба соединения закрываются.
# Понимание этой картины даст понять некоторые директивы.


# Кнт:	http, server, location
# Для Linux 3 директивы обязательны
aio on;                     # по ум. off; используемых при чтении ответа с диска. 
directio       512;         # Разрешает использовать флаги O_DIRECT, нужно это для тоого что бы минимизитовать кеш файловой системы. 
                            # выключит автоматом sendfile
output_buffers 2 32k;      

# Кнт: http, server, location, if в location
sendfile off;               # on - копирование содержимова запрошенного файла осуществляется  ться через функцию sendfile()
                            # напрямую в файл отправки без лишнего этапа помещения данных в буфер это происходит на уровне ядра.
                            # Включить если через nginx отдаём статик файлы, а не через proxy, fastgci подобные директивы.
# Кнт:	http, server, location
tcp_nopush off;             # Разрешает или запрещает использование параметра сокета TCP_CORK в Linux. с sendfile включают.
tcp_nodelay on;             # Разрешает или запрещает использование параметра TCP_NODELAY.

# Режим Keep-Alive по умолчанию включен в nginx. Это технология как я понимаю постоянного соединения клиент-сервер вроде как через socket
# просто директива keepalive  встречаеться в ngx_http_upstream_module, её не стоит как либо отключать.
	
keepalive_timeout 75s;      # Время втечении которого сервер не будет разрываться соединение с клиентом. 


# -----------------------------------------------------------------------------------------------------
# ######--------<{ Безопасность }>----------########
reset_timedout_connection off;    # сбросить соединения по таймауту и освобождить память, тех сокетов которые были по какой-то причине закрыты ? 
                                  #  @включить т.к. сокеты могут быть разорваны при атаке, а память забита и соединение висит с ошибкой.

# -----------------------------------------------------------------------------------------------------
# ######--------<{ Переменные }>----------########
$host;                      # localhost
$hostname;                  # имя контейнера
$date_local;                # Thursday, 11-Mar-2021 14:43:13 UTC 
$uri | $document_uri        # При запросе: 
                            #   domain.ru/test/           -  $uri = /test/, 
                            #   domain.ru/test/index.html -  $uri = /test/index.html.
                            # Всё что автоматом браузер запрашивает будет с файлом: $uri = /assets/css/style.min.css
$request_uri                # Отличие от $uri в том что при запросе domain.ru/test/ будет целая запись  $request_uri = /test/index.html
                                 
$document_root              # Корневая папка: /usr/share/nginx/html
$limit_rate                 # Что-то там с ограничениями связанно.

$remote_addr                # ip сервера
