# Хоть можуля в nginx -V не вижу, но по тестам всё работает.

# Через модуль rewrite можем обработать URI найти нужные нам совпадения через рег.выр. и заменить его от чего nginx начнёт по новой
# искать подходящий location. Можем начать отслеживать URI сразу в директории server или в location где возможно формируем сложную логику.
# 1. rewrite regex    не требует указания   ~ начала активации регулярного выражения как это используеться в location
# 2. Указанно может много rewrite которые выполняються последовательно. Указанные 3м параметром флаги могут прерывать эту цепочку.
# 3. Если в рег. выр. встречаются  "}" | ";", то всё выражение обернуть в одинарные или двойные кавычки.
# Практическое применение примерно такое: Клиент вводит:

# https://example.ru/test/что-то там/
# Мы можем как на уровне директивы server или location (Пример сложноватый из-за регулярки) сказать:
# Если URI /test/ а дальше не index.html (1й аргумерт = истина) то заменим URI на /404/ или любую полезную страницу
# rewrite ^\/test\/(?!index\.html$).+ /404/;

# Ещё пример: Пользователь может набрать: 
example.ru/download/fdfd/media/logo.webp

rewrite ^(/download/).*/media/(.*)\..*$ $1/$2.jpg last;    
# Мы на самом деле обратимся к example.ru/download/logo.jpg. 
# флаг: last останавливает следующие rewrite и возможный стоящий return. 

# Если складываеться впечатление что с if можно обойтись без rewrite, то вот отличие:

  if ($uri ~'/test/.*/') {
    return 404 'мимо';
  }

  rewrite ^/test/.*/ /404/

  location 

# Важно: Мы можем использовать rewrite в location в условии и отсылать снова на этот location. Если не будет
#        Условия то получиться цикл который отработает 10 раз и nginx выдаст 500 ошибку. Пример:

location /download {
  rewrite ^(/download/).* /download/ last;       # с last зациклен за 1м rewrite, 10 раз попадёт в этот location и выдаст 500 ошибку. 
  rewrite ^(/download/).* /test/;                # не былоб last пошёл бы дальше добавив в URI /test/ и ушёл бы туда, не дойдя до /404/ 
  rewrite ^(/download/).* /404/;                 # был бы break; вместо last; то отработал бы 1 раз 1й rewrite и больше не заходили бы в этот location 
}


# Ctx: http, server, location, if
	
rewrite_log off;                  # Можно ли писать в error_log результаты обработки rewrite
uninitialized_variable_warn on;   # нужно ли писать в error_log отдела [warn] предупреждения

# Ctx: server, location, if
# Директивы в server выполняются последовательно или в цикле не более 10 раз 
# 
break;
return --;                        # прерывает отправку файлов отправляя код статуса и сообщение. Вместо кода и сообщения можно указать
                                  # URL nginx автоматически это расматривает как перенаправление с 3xx кодом.
                                  # Обычно после retrun ничего не должно отработать, но add_header отрабатывает, rewrite нет.
                                  # Так же return указаный в в location { if() { return 200 'ff';} } завершит обработку в if, но не в location  
rewrite regex замена [флаг];      # Если "замена" начинается с "http(s)://" | "$scheme", то после rewrite чтение прекращается, клиенту перенаправяется по URL
                                  # флаг: 
                                  #   last  - перестаёт обрабатывать последующие rewrite и ищет новый location соответствующий "Замене".
                                  #   break - перестаёт обрабатывать последующие rewrite и всё.
                                  #   redirect - < временное перенаправление с кодом 302; используется, если "замена" не начинается с "http(s)://" | "$scheme"
                                  #   permanent - < постоянное перенаправление с кодом 301; 
                                  # Пример: попав в location /test {
                                  #   rewrite ^(/test/.*) /ro/;         # заменим URI на /ro/ и nginx найдёт пойдёт искать location /ro
                                                                        # в котором 
                                  # }
                                    
set $переменная значение;         # добавление переменных 
# Ctx: server, location
if () {};                         # директивы повторяющиеся вне тела условия, работать не будут, только если их нет в теле и 
                                  # если установить break; в теле условия, то за пределами чтение директив прекращается.
                                  #  "=", "!=" - сравнивать можно только переменную с значением, но не значение со значением.
                                  #  Пример: set $a 14
                                  #    if ($a = 14) - можно  if (14 = 14) - нельзя
                                  #  "~" | "~*"  - проверка рег.выр. с учётом регистра и без него. отрицательная запись: "!~", "!~*", 
                                  #  Пример: 
                                  #    if ($http_user_agent ~* MOZILLA)  с лева считаеться рег.выр.
                                  #    if ($http_cookie ~* "id=([^;]+)(?:;|$)")  рег.выр. оборачиваеться в строку если есть ; или } 
 
                                  # "-d" и "!-d" - проверка директив, "-f" и "!-f" - проверка файлов.
                                  # "-e" и "!-e" - проверка существования файлов, директив или  ссылки ,
                                  # "-x" и "!-x" - проверка исполняемости файла.

# Есть директива add_header у которой контекст http, server, location, if в location, но почему-то 

server{
  if (условие) {            
    add_header One 123;       # Так выдаёт ошибку: "директива здесь не разрешена", при этом без if, работает 
  };
  location /test {
    if (условие) {            
      add_header One 123;     # а так норм.
    };
  }
}

# Как нужно перенаправлять
# Не правильно: 
server {
    listen       80;
    server_name  www.example.org  example.org;
    if ($http_host = example.org) {
        rewrite  (.*)  http://www.example.org$1;
    }
    ...
}
# Правильно:
server {
    listen       80;
    server_name  example.org;
    return       301 http://www.example.org$request_uri;
}

server {
    listen       80;
    server_name  www.example.org;
    ...
}