/*
  nginx состоит из модулей, которые настраиваются директивами, указанными в конфигурационном файле. 
  Директивы делятся на простые и блочные. Простая директива состоит из имени и параметров, разделённых пробелами,
  и оканчивается точкой с запятой (;) Пример: 
  Простая: Имя_директивы название_параметра;       Пример: server_name имяСервера; 
  Блочная: Имя_директивы название_параметра { доп.конфигурация }    Пример: location / { } - такие директивы называются "контекстом".


1. Каждый блок server {} - это отдельный независимый сервер.

2. nginx обрабатывает первым конфиг listen потом ищет сходство с заголовком запроса Host и директивой server_name
    определившись с сервером обрабатывает location с простыми роутами, а после с роутами состоящих из рег. выражений.

3. По умолчанию прослушивается 80й порт. Если несколько server's прослушивает 80 порт, то каждому server надо указать server_name
   с именами доменов. У какого сервера совпадает имя домена тот и обрабатывается.
   Если нет совпадений обращается к 1му или у которого в listen префикс default_server.

4. location / подходит под все Route's, но nginx сопоставляет запрашиваемый Route с подходящим самым длинным location.
   При первом совпадении поиск прекращается. Если не подходящего обращается к /.
   
5. location складывается с директивой root | pass_proxy | fast_proxy. 
    location смотрит с чего начинается URI не обращая внимания на query параметры. /test/index.php ?user=john&page=1  
  Запрос: example.com/images/img.jpg  
   location /images {                 # этот location обработает любые запросы начинающиеся с URI /images
     root: /data/www                  # /data/www/images или
     pass_proxy http://domain.ru      # http://domain.ru/images    fast_proxy - тож самое
   }
   location = /images/ {              # обработает только одно точное совпадение "example.com/images/" не больше ни меньше.
    ...
   }   

  Поведение меняется при использовании alias вместо root в location
  

  
6. ~ - это сигнал начала регулярного выражения. ^~ - Повышает приоритет выражения. ~* (аналог / /i) -  не чувствительно к регистру. 

7. Когда nginx попадает в какой-то location и проверяет параметр index на существование главного файла index.html или index.php
   и если не существует index.html, а существует index.php, то nginx снова пробегается по location в поисках подходящего обработчика
   т.к. php файлы должен обрабатывает FastCGI. 
8. Кеширование стоит использовать в случаях если страница редко меняется.
---------------------------------------------------------------------------------------------------------
#######-------<{ Описание работы nginx }>--------########
/etc/nginx/nginx.conf - Гл. конф. файл считается контекстом main, в котором 2 блочных директивы ({ } - блочная)
                   
events { }

http { 
  include /etc/nginx/conf.d/*.conf; - Обычно директиву server выносят в другой файл. * - файлов с server может быть несколько   
}  
                                              

/etc/nginx/conf.d/default.conf  - настройка server по умолчанию. 
ВАЖНО: Синтаксис смахивает как объекты в объектах, но там не нужно указывать: 

  server { 
    listen 80;                  # По. ум. Прослушивает 80й порт. можно не указывать. Принимает так же ip
    server_name  domain.ru      # Если директив server {} будет несколько, то им указать домены за которые они отвечают
    location / { }              # обрабатывают запросы как каталог или файл или же с использованием alias обработают как route
    location /images/ { }       
  }
  

---------------------------------------------------------------------------------------------------------
#######-------<{ Директива location }>--------########
  root /home/app    
  location / {}           # domain.ru                        /home/app/index.html      
  location /image {}      # domain.ru/image/1.jpg            /home/app/image/1.jpg
  location /css {}        # domain.ru/css/style.min.css      /home/app/css/style.min.css
 
  Все варианты выше реагируют на префиксы. Пример: location images отработает в нескольких случаях
  если мы запросим так: domain.ru/image.jpg. или domain.ru/image/1.jpg ну или если нет доп обработки
  будет отрабатывать на любой запрос начинающийся с image:  domain.ru/image/бла/бла/бла/1.jpg
  Неудобство заключается в том, что во 2м случае images должна быть реальной директорией 
  в которой должен быть этот файл, потому-что root складывается с location
 
Начнём с корня каталога приложения.

  Пример:  domain.ru/test.html.  Сложив root и location получаем /home/app/запрашиваемый_файл.html или /запрашиваемая_директория

  root /home/app   
  location / {
    index index.html;             # отработает если: domain.ru или domain.ru/файл.рас. Отработала бы на 
    add_header x one;             # domain.ru/test... но раз обработка существует ниже, то не будет.
                                  # 
  }
  location /test {
    index test.html;              # отработает если: domain.ru/price.html и файл есть рядом с index или 
    add_header x two;             # или если мы рассчитываем что есть каталог test: domain.ru/test/ в котором должен быть файл 
  }                               # указанный в директиве index. тогда отработает domain.ru/test/ и смысл от директивы index есть или 
                                  # мы на прямую обратимся к файлу:  domain.ru/test/image1.jpg


  * nginx автоматически (если не используем рег.выр. в location) сохраняет конструкцию location + "/" + директиву index,
    переходит по ней. В URI оставляет лишь location + "/",  а полную конструкцию передаёт в root. 
    На предполагаемый запрос: http://domain.ru/ro/index.html
    правильно запрашивать: http://domain.ru/ro/ - верно,   не правильно:  http://domain.ru/ro - не верно. Не загрузит.

Разница location /test {} или location /test/ {}

    location / {
      add_header x one;            
    }

    location /test/ {              # Теперь на запрос: domain.ru/test1.html хоть и встречается /test... этот location
      index test.html;             # обрабатывать не будет т.к. /test/ это явно указан не файл, а каталог в случае с использованием root.
      add_header x two;            # Поэтому отработает location / {}.
    }


  Поведение складывания root с location можно изменить и перестать воспринимать location как директиву или возможное имя файла,
  а думать о ней как о просто выдуманном роуте. Нужно использовать alias "путь к файлу", а location как Rout.
  * В alias "путь" можно использовать переменные, кроме $document_root и $realpath_root.

  alias складывается с запрашиваемым файлом или если в запросе файл не указали, складывается 
  с директивой index. При любом раскладе складывание без конструкции location. 
  Хочу заметить что лучше в конце alias указывать /. 
  Тогда location нормально реагирует на замкнутые конструкции /test/

  location /image {                      
    alias /usr/share/nginx/html/img/;   # domain.ru/image/1.jpg                    /usr/share/nginx/html/img/1.jpg 
    index 1.jpg                         # domain.ru/image/   - запрос с index.     /usr/share/nginx/html/img/1.jpg 
  }

  Теперь можно выдумывать Rout's и не зависеть от директорий.

  location /image/rr/dd {
    alias /usr/share/nginx/html/img/;    # http://localhost:5000/image/rr/dd/1.jpg    /usr/share/nginx/html/img/1.jpg 
    index 1.jpg;                         # http://localhost:5000/image/rr/dd/         /usr/share/nginx/html/img/1.jpg
   
  }


Если установлен proxy на корневой Rout и нет соответствий в location то запрошенный Rout передаётся на проксируемый
сервер. Если в nginx есть такой Rout и на проксируемом сервере, то в nginx приоритет выше. 
  
 root /usr/share/nginx/html;

  location / {
	  proxy_pass http://server_node:4000;         
	}
  location /price {
    index test1.html;                   # в nodejs тоже есть Rout /price тянет данные с дб, но тут приоритет выше
    alias /usr/share/nginx/html;        # вывожу просто test1 на запрос http://domain.ru/price/    кстате 
    add_header x one;                   # на node отработало бы без /: http://domain.ru/price т.к.данные, а не файл
	}                                     # но Rout /price/ полностью занят nginx и убрать в конце / не даст результата, но... 
  location /price/ {                    # Что если указать так /price/ ? nodejs будет уже отвечать на http://domain.ru/price
    index test.html;                    # nginx учитывает только ~.../price/ c использованием alias видим 403 Forbidden. Не понятно.
    alias /usr/share/nginx/html/;       # Если обработаем как каталог без alias, то root и location = /usr/share/nginx/html/price/ 
    add_header x one;                   # Добавив alias в конце / исправило ситуацию. Видимо между alias и index как-то перепадала / 
	}                                     # со стороны location. Теперь .../price обрабатывает node, .../price/ обрабатывает nginx


  Кстате все запросы в которых присутствует в начале /price/что-то там/ будут соответствовать обработке location /price/ {}
  
  У location есть доп символы: =, ^~,  ~,
    location = /profile {} найти полное точное совпадение. ( по сути каталог а не файл раз нет расширения )
                           теперь /profile/что-то там отрабатывать не будет
    location ^~ ^(p.+e) {} имеет выше приоритет перед другими регулярными выражениями.
    location ~ ^(p.+e) {} начало использования регулярного выражения


  Ещё интересный вариант:
    Поиск как было сказано выше осуществляется с корня "location /" и дальше в нашем случае "/price".
    Если установить = то поиск будет происходить в точном расположении. Раз не указанно /price.html или ещё какого расширения,
    ну значит это должен быть каталог. Если он есть то будет взят оттуда index.html или тот что указан в директории index 
    (если он есть конечно иначе в любом случае index.html)

  location = /price {
    index test1.html;                 # тут можно не запариваться с alias. На запрос: http://localhost:5000/price/
    alias /usr/share/nginx/html/;     # получим файл root + location. Ни alias, ни index тут не повлияли и не передали 
    add_header x one;                 # существующий /usr/share/nginx/html/test1.html. Об этом после регулярных выражений.
	}


-----------------------------------------------------------------------------------------------------------
#######-------<{ регулярное выражения и маски в nginx }>--------########*/

// location ~* (.*/myapp)/(.+\.php)$ {
//   ...
// }

/*
  Первая группа проверяет есть ли что либо перед /myapp/, вторая проверяет какое либо название файла.
  Группы автоматом записываются в переменные $1, $2 и т.д. Сколько групп столько переменных. Вроде как таких групп может быть $1-$9 
  Так же в nginx можно задать именованные переменные: 
*/

//  location ~* (?<begin>.*/myapp)/(?<end>.+\.php)$ {
//    ...
//  }

/*
  Это имена переменных в группах: (?<begin>...), (?<end>...) всё что после ?<begin> и ?<end> записывается в них. 
  Возможные варианты: ?<begin> ?'begin' ?P<begin>

  Далее можно использовать в конфиге $begin и $end.

  Пример:
  server{
    server_name: ~^www\.(?<domain>\w+)

    location / {
      root $domain/assets
    }
  }

  Так же говорят что использование фигурных {1,4} нужно экранировать.
  server_name  "~^(?<name>\w\d{1,3}+)\.example\.net$";    При этом я не вижу экранирования {} и выдаваемой ошибки тоже нет.

--------------------------------------------------------
  server_name *.domain.com www.example.*   - маски nginx могут быть только в начале или в конце и только возле точки
                                             означают маски: Любой текст. 
                                             Пример: www.sub.domain.com соответствует маске *.domain.com



-----------------------------------------------------------------------------------------------------------
#######-------<{ alias с регулярным выражением }>--------########
  Судя по экспериментам alias с использованием регулярного выражения не работает с директивой index.
  Минус заключается в том, что придётся вводить полную конструкцию с именем файла.

  Без рег.выр. в location, в alias не стоит напрямую указывать файл 500 ошибка, это не работает: alias /usr/share/nginx/html/index.html;
  но c рег.выр. в определённой конструкции работает.



По ощущениям где-то записывается переменная так: location + "/" + index и автоматом добавляется:
без рег.выр.:   в URI - без index директивы,   в alisa - только index,   в root - вся конструкция. 
с рег.выр. не добавляется "/" автоматически в location, всё указывается в ручную. 
    в URI - /location/ + index/,  в alisa - не попадает,   в root - вся конструкция. 


Разбор неправильного использования alias:*/

  // location ~ .*/price {                    # Запрос: domain.ru/price не отработает т.к. если мы рассчитываем манипулировать файлами. такой конструкции 
  //   index index.html;                      # нет для файлов nginx не понимает. Есть замкнутая конструкция для файлов .../price/ подразумевающая каталог 
  //   alias /usr/share/nginx/html/;          # или route за которым есть файл, но он скрыт т.к. повторяется в директиве index. 
  // }

  // location ~ .*/price/ {                   # Запрос: domain.ru/price/ с root без проблем работает. root = location + "/" + index,
  //   index index.html;                      # но с alias запрос не продвигается. Ощущение будто без root в рег.выр. при запросе
  //   # root /usr/share/nginx/html;          # domain.ru/price/ в запрос не передаётся директива index, поэтому нет запроса файла как таковой.
  //   alias /usr/share/nginx/html;           # index без root не влияет. 
  // }

  // location ~ .*/price/ {                     # Это объясняет почему получаем 500. При запросе index не domain.ru/price/ index с alias
  //   alias /usr/share/nginx/html/index.html;  # не работает, мы переходим по route получается без файла, попадаем в location а там без 
  // }                                          # запроса на файл отдают файл. Сервер не верно настроен. 
  //                                            # Но при запросе domain.ru/price/f.html ошибки нет. Сервер понимает что запрашивается какой-то файл
  //                                            # и отдаёт index не парясь и кстате любые другие запрошенные файлы, при одном location ~ .*/price/ {}


/* Вывод: директива index передаётся когда указан root или если alias но без рег.выр в location. 
          Видимо нет смысла использовать директиву index с alias + рег.выр.

  Правильное использование рег.выр. c alias:

  Предположим что мы придерживаемся того что папки и location у нас разные, экспериментируем с alias дальше.
  Склеивание происходит таким образом:*/

  // location ~.*/price/(\D+.html) {                # Обратились к domain.ru/price/index.html так работает. Отправим файл из корня
  //   alias /usr/share/nginx/html/$1;              # .../html/index.html. как и сказал минус это указывать имя да ещё правильное 
  // }                                              # в URI

/*
  Вывод:  Рег.выражение должно обрабатывать имя файла тип того ...(\D+.html) и alias должен отдавать так же файл.
          и что самое важное ЛУЧШЕ НЕ ИСПОЛЬЗОВАТЬ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ т.к. работают медленней точных значений.
        


-----------------------------------------------------------------------------------------------------------
#######-------<{ Перебор данных на основе запроса }>--------########
В nginx меня напрягает запрашивать файлы. Связь alias + index или root + location + index обязательно
добавит в конце "/". Яб хотел в некоторых ситуациях избавиться от него.

При такой конфигурации: 
  location = /style {
    index style.min.css;                                      # Приходиться не забывать "/" в конце. http://domain.ru/style/ 
    alias /usr/share/nginx/html/assets/css;                   # Иначе 404. 
  }
  location = /style {
    alias /usr/share/nginx/html/assets/css/style.min.css;     # Получили то что хотели. http://domain.ru/style выдаст style.min.css файл
  }                                                       



Что если нам надо отдать не конкретный файл а какой-нибудь из существующих? допустим напарник хочет посмотреть код стилей
style.css или style.scss или накрайняк style.min.css. Можно закинуть файл в нужную папку и сделать проверку.

  location = /style {                            # на запрос: domain.ru/style try_files проверяет каждый существование каждого файла,
    try_files /css/style.css                     # складывая alias | root  + try_files файл1 файл2 ... файл4 =404. 
              /css/style.min.css                 # Если файл находит прекращает цикл и отдаёт файл. Файлов нет в конце так указывается  
              /scss/style.scss =404;             # код ошибки. Кстате location не участвует тут с root. Можем использовать $uri
    alias /usr/share/nginx/html/assets;                                   
  }                                                                       

  location = /test {                             # $uri - хранит всё что после domain.ru, а не location. При запросе: domain.ru/test
    try_files $uri/index.html                    # или дале domain.ru/test/ получим: .../nginx/html/[test/index.html, ...]
              $uri/index.php                     # со 2м запросом: .../nginx/html/[test//index.html, ...] и всё равно отрабатывает
              $uri/test2.php =401;               # ВАЖНО: $uri В РАЗНЫЙ МОМЕНТ ВРЕМЕНИ ИМЕЕТ РАЗНОЕ ЗНАЧЕНИЕ. При запросе example.ru/test/
                                                 # $uri = /test/, но отправив add_header x $uri увидим $uri = /test/index.html
    root  /usr/share/nginx/html;
    add_header x $uri;                           # Кстате если посмотреть $uri после того как открылась страница, увидим в заголовках 
  }                                              # /test/index.html хотя get запрос на domain.ru/test. $uri обновилась в момент отправки файла.
  
-----------------------------------------------------------------------------------------------------------
#######-------<{ Как в nginx обработать ошибки }>--------########
  Случай 1й. 
  Мы имеет некоторые location и хотим выдавать 404 страницу на любые location которых у нас нет;
    server {
      location / {}
      location /test {}
      location /price {}

      error_page 404 =200 /404.html;        # На запрос: example.ru/zxc, вызывается 404.html файл, он может запросить стили,
                                            # если запрос example.ru/zxc/vbn то 404.html не сможет получить стили т.к. запрос
                                            # стилей будет  example.ru/zxc/style.min.css
  Такой подход должен использоваться без подключений файлов в 404.html. Что бы это обойти нужно
  тогда указывать обработчик location для стилей например:

*/   
    // location ~ .*/(\w+\.(min\.)?css)$ {
    // alias /usr/share/nginx/html/assets/css/$1;
    // }
    // location ~ .*/(\w+\.(ico|png))$ {
    //   alias /usr/share/nginx/html/assets/img/$1;
    //   add_header ico 1;
    // }
/*
    }
 
  
  Есть ещё вариант, но он громоздкий.Каждый location проверять и менять URI на 404, после отработает location 404.
  Тут так же стоит вопрос обработки стилей для 404 на любом неверном роуте.

    location /route2 {
    rewrite ^\/route2\/(?!index\.html$).+ /404/ last;
    alias /usr/share/nginx/html/ro/;
  }

  location /route1 {
    rewrite ^\/route1\/(?!index\.html$).+ /404/ last;
    alias /usr/share/nginx/html/test/;
  }
 
  location /404 {
    index 404.html;
    alias /usr/share/nginx/html/;
  }
  


-----------------------------------------------------------------------------------------------------------
#######-------<{ Как nginx обрабатывает запросы }>--------########
  Если сервера прослушиваю один и тот же порт то nginx проверяет ещё и заголовок запроса Host и сопоставляет это имя
  домена с каждым server_name. Если есть совпадение обрабатывает этот сервер, если нет выбирает 1й сервер или 
  у которого в listen префикс default_server. 
 
  server {
    listen      80;
    server_name example.net www.example.net;
    ...
  }
  server {
    listen      80 default_server;
    server_name example.org www.example.org;
    ...
  }
  --------------------------------------------------------
  Но заголовка запроса Host может и не быть (localhost автоматом добавляет). можно определить сервер 
  с пустым server_name который соответствует отсутствию заголовка Host. 444 код специальный для nginx
  Закрывает соединение.(Страница будет недоступна)

  server {
    listen      80;
    server_name "";
    return 444;                    # Нестандартный код 444 закрывает соединение без передачи заголовка ответа.
  }                                # Завершает обработку в УКАЗАННОЙ ДИРЕКТИВЕ и возвращает клиенту указанный код.. 
                                   # подробней про return в ngx_http_rewrite_module
  
  --------------------------------------------------------
  Если указан ip, то проверяется ip и порт, потом сопоставляет заголовок запроса Host с server_name.
    Пример: 1.

  server {
    listen      192.168.1.1:80;     
    server_name example.org www.example.org;
    ...
  }
  server {
    listen      192.168.1.2:80;
    server_name example.net www.example.net;
    ...
  }
  --------------------------------------------------------
  У разных ip могут определены свои сервера по умолчанию.
    Пример: 2.

  server {
    listen      192.168.1.1:80;     
    server_name example.org www.example.org;
    ...
  }

  server {
    listen      192.168.1.1:80 default_server;
    server_name example.com www.example.com;
    ...
  }

  server {
    listen      192.168.1.2:80 default_server;
    server_name example.com www.example.com;
    ...
  }



-----------------------------------------------------------------------------------------------------------
#######-------<{ nginx как прокси }>--------########
  nginx может обрабатывать несколько серверов со своими location (буду называть их роутами route)
- 2 независимых сервера

  server { 
    listen 80                         Если порт не менять то можно опустить т.к. nginx по умолчанию прослушивает 80й порт
    location / { ... }
    location /images/ {               Помним что nginx складывает root и location и получем путь по которому 
      root /data;                     он ищет запрашиваемые данные. тут: при get обращении к /images будет поиск  
    }                                 данных на локальной машине по пути /data/images/img1.jpg. location / так же отрабатывает,
    ...                               но nginx ищет подходящий
  }
  server { 
    listen 8080
    location / { ... }
    location /source/ { 
      root /data; 
    }
    ...
  }
--------------------------------------------------------
Один сервер может ссылаться на другой через proxy. 
- сервер proxy 

  server { 
    root /data/public                  вынесенный root будет отрабатывать если подошла какая либо location и в ней нет root  
    location / {                       и нет проброса через proxy_pass иначе root будет браться на том сервере куда идёт проброс
      proxy_pass http://localhost:8080        Так примерно проксируют на nodejs приложение вместо 2й директивы server, но в чём смысл?
    }                                      
    location ~ \.(gif|jpg|png){       \. экранированная точка (варианты расширений),
      root /data/images;              запросы будут ссылаться на каталог /data/images/ *.gif  | *.jpg  | *.png.  
     }       
     ...
  }

  server { 
    listen 8080
    root /data/up1;                   
    location / { ... }                
  }

Примерно это работает так: 
  nginx прослушивает 80й порт и ждёт запросы. На запрос nginx пробегается по всем location ищет подходящий
  для запроса location и запоминает его далее пробегается по location с рег.выражениями если они не подходят 
  возвращается к тому подходящему который запомнил иначе обрабатывает location c рег. выражением.  
  Все запросы которые не подошли отправляет на proxy_pass
  
  ----Проксирование на nginx------------------------------

  server {

  server_name localhost;
  listen 80;
  
  location / {
    index index.html;
    root /usr/share/nginx/html;
  }

  location /price {
	  proxy_pass http://server_node:4000;
	}

}

Запрашиваем http://localhost:5000/price  префикс добавляется http://server_node:4000/price. А там уж как мы этот роутер обработали.


--------------------------------------------------------
Nginx не может напрямую работать с php файлами, но он может передать запрос через FastCGI канал предварительно установленной программе
которая сможет обработать этот файл. Например есть программа PHP FPM.  apk add php8-fpm  
Что странно, её процесс будет называться php-fpm8 (в /etc/init.d) в Alpine потребуется поставить openrc и использовать rc-service  
Соединение с ней можно осуществить через port 
Пример: (127.0.0.1:9000) или через unix socket (/var/run/php-fpm.sock)  
  FastCGI - серверы на которых могут исполняться приложения, созданные с использованием разнообразных 
            фреймворков и языков программирования, например, PHP.

  для работы с FastCGI-сервером требуется директивы с пометкой fastcgi. 
  fastcgi_pass вместо директивы proxy_pass

  server {
    location / {
        fastcgi_pass  http://localhost:9000;                 
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;    
        fastcgi_param QUERY_STRING    $query_string;
    }
    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
  }
  Все запросы, кроме запросов статических изображений, будут перенаправляться на проксируемый сервер.




-----------------------------------------------------------------------------------------------------------
#######-------<{ обработка запросов сайта на php }>--------########
  Запрашивая "/index.php" мы должны обрабатывать этот запрос через FastCGI. Что если запрос просто "/"?
  Мало того что запрос "/" попадает под location / и так же соответствует проверке параметра index на
  существование главного файла index.html. Если его не находит ищет index.php. Найдёт index.php
  и делает по новой поиск по всем location т.к. он знает что файл должен обрабатываться через FastCGI.
  Запрос "/about.html" так же попадает в location /, однако нет нужды проверять index параметр. root складывается с
  location и получаем /data/www/about.html; nginx отсылает ответ.

server {
    listen      80;
    server_name example.org www.example.org;
    root        /data/www;

    location / {
        index   index.html index.php;
    }

    location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }

    location ~ \.php$ {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME
                      $document_root$fastcgi_script_name;
        include       fastcgi_params;
    }
}

Однако не понятно если root складывается с location и нам нужен такой uri domain.ru/images/alb1 то получаем путь
/data/www/images/alb1; файловой системы. У нас get запрос привязан к папкам? Может у меня в другом каталоге
/data/www/img/folder1



-----------------------------------------------------------------------------------------------------------
#######-------<{ балансировщика нагрузки upstream_module }>--------########
  
  Балансировка требуется для крупных сайтов и nginx имеет блочную директиву upstream отвечающую за этот процесс.
  upstream записывается на одном уровне с директивой Sever, при этом у неё так же указывается конфигурация server.  
 
  Балансировка нагрузки - это распределение входящих запросов на ряд других серверов, на каждом из которых 
                 работает копия веб-приложения (сайта). Это обеспечивает улучшение времени отклика сайта и
                 устойчивость сайта. Если будут проблемы с 1м сервером ещё будет несколько рабочих.
  Балансировку так же могут иметь и базы данных. 
  Балансировщики нагрузки обычно делятся на аппаратные и программные.

  Не уверен, но вроде реализованно это через proxy. Так же балансировка делиться на уровни вроде как.

  Методы балансировки нагрузки:

  round-robin - запросы к серверам приложений распределяются циклически. Пример: 5 запросов первые, 1,2й сервер по 2 запроса получат, 
                3й только 1запрос уйдёт, По ум. если не настроены другие методы.
  least-connected - запрос пойдёт к серверу с наименьшим количеством активных подключений,
  ip-hash - хеш-функция используется для определения, какой сервер следует выбрать для следующего запроса (на основе IP-адреса клиента)


  Конфигурация балансировки нагрузки по умолчанию:
  http {
    upstream myapp1 {                           # таких директив upstream может быть несколько со своими группами серверов
        # less_conn;                            # и настроены под свои route в location.
        # ip_hash;
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }

    server {
        listen 80;
        server_name domain.ru;                  # Запрос: domain.ru перенаправляет на http://myapp1 который указан в специальном upstream 
        location / {                            # параметре в котором есть 3 сервера srv1-srv3, которые по ум. используют метод round-robin.
            proxy_pass http://myapp1;           # Если включить less_conn в группе upstream то балансировка будет работать в least-connected                               
            proxy_set_header Host $host;        # конфиге. nginx может выдать 404 ошибку используя proxy, добавив host должно помочь
        }                                       
    }
  }

Что с round-robin или least-connected каждый последующий клиентский запрос потенциально может быть распределен на другой сервер.

Если есть необходимость привязать клиента к определенному серверу - использовать механизм ip-hash.
Метод гарантирует, что запросы от одного и того же ip(клиента) будут направлены на один и тот же сервер, 
если конечно сервер доступен.

Взвешенная балансировка нагрузки может устанавливать кол-во запросов к серверу:
   upstream myapp1 {
        server srv1.example.com weight=3;           # Например если у нас первый сервер чуть мощней и по ум. запросы передаются циклом 
        server srv2.example.com;                    # по 1 на сервер, мы может например при 5 запросах на 1й сервер передать 3, на 2й и 3й уйдёт по 1.
        server srv3.example.com;
    }
Таких как weight параметров есть некий список:
  weight=1            # устанавливает кол-во принимаемых запросов за 1 итерацию (режим round-robin).
  max_conns=0         # по ум. нет ограничений. Ограничивает максимальное кол-во одновременных активных подключений.
  max_fails=1         # кол-во безуспешных попыток связи с сервером за период времени в fail_timeout, что бы считать его недоступным.
  fail_timeout=10s
  backup              # помечает сервер как резервный. Запросы будут передаваться, когда основные серверы недоступны.
  down                # помечает сервер как постоянно недоступный. Можно указать если нужно провести тех обслуживание сервера.
    ---Остальные только в коммерческой версии--- 
  resolve
  route=str
  service=name
  slow_start=time
  drain



Есть директива stream которая записывается на одном уровне с http директивой(то есть в главном файле).
Это немного сокращает код предыдущей записи. В директиве server не требуется указывать location / {}.
Иак же не требуется в proxy_pass указывать http:// 
Как говорят это транспортный режим балансировки

stream {
  upstream dns_backends {
    server 8.8.8.8:53;                        # 2 DNS сервера. DNS отвечает за 53 порт
    server 8.8.4.4:53;
  }

  server {
    listen 53 udp;                            # пока не знаю зачем тут UDP и что этим хотели сказать
    proxy_pass dns_backends;
    proxy_responses 1;
  }
}

СТАТЬЯ НЕ ЗАКОНЧЕНА.



-----------------------------------------------------------------------------------------------------------
--------------------------------------<{ Настройка HTTPS-серверов }>---------------------------------------

3 основных шага включения HTTPS протокола:
  1. Перейти на 443 порт с указанием ssl параметра
  2. Указать местоположение ssl сертификата
  3. Указать ssl сертификата ключ. Секретный ключ следует хранить в файле с ограниченным доступом 
     (права доступа должны позволять главному процессу nginx читать этот файл

  Сертификат посылается каждому клиенту, соединяющемуся с сервером.
  SSL-операции потребляют дополнительные ресурсы процессора.
  В 1 мегабайт кэша помещается около 4000 сессий.

server {
    listen              443 ssl;                      # HTTPS это 443 порт, а не 80 и указывается параметр ssl 
    server_name         www.example.com;              
    ssl_certificate     www.example.com.crt;          # сам сертификат
    ssl_certificate_key www.example.com.key;          # его ключ
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers         HIGH:!aNULL:!MD5;
    ssl_session_cache builtin:1000 shared:SSL:10m;    # т.к. ssl потребляет ресурсы процессора, builtin - кэш, кол-во сессий в рамках 1 процесса
                                                      # shared - размер кеша в байтах, килобайтах, мегабайтах. Эффективней использовать 1 параметр
    ssl_session_timeout 10m;                          # какое-то время кеша 
}


Могут возникнуть проблемы при использовании 2х серверов на одном и том же 443 порту, поэтому требуется приписывать явно ip адреса
 server {
    listen          192.168.1.1:443 ssl;
    server_name     www.example.com;
    ssl_certificate www.example.com.crt;
    ...
}

server {
    listen          192.168.1.2:443 ssl;
    server_name     www.example.org;
    ssl_certificate www.example.org.crt;
    ...
}


-----------------------------------------------------------------------------------------------------------
--------------------------------------<{ nginx по мелочи }>------------------------------------------------

В целом об nginx:
  - Может использоваться как сервер который отдаёт статику сайта
  - Использоваться как proxy сервер перенаправляя запросы на нужные сервера
  - Использоваться как балансировщик нагрузки. Так же использоваться балансировщиком на транспортном уровне.



  Nginx имеет 1 master process и выставленное кол-во worker process, и пара вспомогательных
  кэш-процессов:  cache manager(CM иногда просыпается подчищает кеш) и cache loader(CL) - как их активировать пока не знаю

  Процесс и поток - это наборы инструкций. В процессе есть информация о потоке(ах). 
  По запросу OS поток(и) вызываются ядром(и). 
  Каждый процесс потребляет некоторое кол-во памяти.
  Современные серверы справляться с сотнями активных процессов с кучей потоков,
  но производительность страдает если заканчивается память или огромное кол-во операций ввода-вывода.

НАПРИМЕР У APACHE 1 соединение 1 рабочий процесс; NGINX рабочие процессы с множеством потоком поэтому их 
меньше 10 в основном.


-----------------------------------------------------------------------------------------------------------
#######-------<{ Единицы измерения в конфигурационном файле }>--------########
  “1024”, “8k”, “1m”  - размеры. Байты, килобайты, мегабайты.
  ms - миллисекунды, s -секунды, m - минуты, h - часы, d - дни, w -	недели, M -	месяцы, 30 дней, y - годы, 365 дней
  Например, “1h 30m” задаёт то же время, что и “90m” или “5400s”. 

  Некоторые интервалы времени можно задать лишь с точностью до секунд.



-----------------------------------------------------------------------------------------------------------
#######-------<{ Отладочный лог }>--------########
  Пока не совсем понятно накой х это надо. Вроде как можно составить собственный вид логов

  ./configure --with-debug ...     чёт в контейнере не работает
  error_log /path/to/log debug;   указать ключ debug
    Прописать nginx -V проверив файл конфигурации. Там указан путь с модулями: --modules-path=/usr/lib/nginx/modules
    


  Лог можно сохранять в буфере а не в файловой системе,
    error_log memory:32m debug;
  но извлекать его потом придётся каким-то кудрявым gdb-скрипта. Пример в доках. 

  Так же можно помещать в syslog:
    error_log syslog:server=192.168.1.1 debug;
    access_log syslog:server=unix:/var/log/nginx.sock,nohostname;
    access_log syslog:server=[2001:db8::1]:12345,facility=local7,tag=nginx,severity=info combined;

  syslog
    server=адрес        Задаёт адрес сервера syslog.Адрес может быть указан в виде: домена, IP
                        и необязательного порта, или в виде пути UNIX-сокета.
    facility=строка     Категорию сообщений syslog в соответствии с RFC 3164. Возможные значения:
                        “kern”, “user”, “mail”, “daemon”, “auth”, “intern”, “lpr”, “news”, “uucp”, “clock”, “authpriv”,
                         “ftp”, “ntp”, “audit”, “alert”, “cron”, “local0”..“local7”
    severity=строка     Важность сообщений syslog для access_log в соответствии с RFC 3164. По ум. “info”
    tag=строка          Задаёт метку сообщений syslog. По умолчанию используется “nginx”.
    nohostname          Запрещает добавление поля “hostname” в заголовок сообщения syslog



  
  Отладочный лог для определённого клиента(ов) Указывается в 
  events {
    debug_connection 127.0.0.1 или localhost или 192.0.2.0/24 или ::1 или 2001:0db8::/32 или unix:;
    Пример:
      debug_connection 192.168.1.1;
      debug_connection 192.168.10.0/24;
 
  }

-----------------------------------------------------------------------------------------------------------
#######-------<{ Сборка nginx с новыми модулями. Пример brotli }>--------########
  Как правило мы ставим боевой nginx смотрим поддержку его модулей nginx -V и видим недостающие модули.
  По всей видимости что бы их добавить придётся качать не собранную версию nginx и собирать скопировав
  модули с собранного(рабочего) nginx.

  1. Скачать чистый не собранный nginx и brotli
      curl -O https://nginx.org/download/nginx-1.19.8.tar.gz
      git clone --recursive https://github.com/eustas/ngx_brotli.git
  2. Распаковать tar xvf nginx-1.19.8.tar.gz -C ./src
  3. Зайти cd src/nginx-1.19.8
  4. Для сборки nginx понадобятся пакеты:  
      apk --update add gcc make g++ zlib-dev linux-headers pcre-dev openssl-dev возможно потребуется
      (доп. если буду ошибки: gnupg libxslt-dev gd-dev geoip-dev libc-dev )
      для других linux apt-get build-dep nginx

  5. Можем получить список команд ./configure --help или скопировать из рабочего nginx -V
     ./configure --prefix=/etc/nginx ....... --with-debug(офф.модуль) --add-module=путь_к_модулю

    Возможные ошибки: 
         ./configure: no supported file AIO was found
          Currently file AIO is supported on FreeBSD 4.3+ and Linux 2.6.22+ only
          Модуль --with-file-aio  требует пакет: "linux-headers"

          ./configure: error: the HTTP rewrite module requires the PCRE library.
          You can either disable the module by using --without-http_rewrite_module
          option, or install the PCRE library into the system, or build the PCRE library
          statically from the source with nginx by using --with-pcre=<path> option.
          Требует пакет: "pcre-dev" 

          ./configure: error: SSL modules require the OpenSSL library.
          You can either do not enable the modules, or install the OpenSSL library
          into the system, or build the OpenSSL library statically from the source
          with nginx by using --with-openssl=<path> option.
          Требует пакет: "openssl-dev"


  6. Команда make собирает. Можем зайти в папку objs ввести ./nginx -V
  7. Команда make install переустановит рабочий nginx на новый
 

  Есть ещё вариант установки модуля запакованного в .so формат (Динамический модуль).
  С 5 пункта делаем следующее:
  ...
  5. Вместо --add-module=путь_к_модулю ставим --add-dynamic-module=путь_к_модулю
  6. Команда make modules добавит в objs модули
  7. Команда make install переустановит рабочий nginx на новый

  8. Что бы модуль заработал его в nginx.conf нужно подключать. В моём случае:
      load_module modules/ngx_http_brotli_filter_module.so;
      load_module modules/ngx_http_brotli_static_module.so;

  Как я понял --add-dynamic-module нужна просто для создания модуля *.so и все шаги именно для этого,
  но если у нас на руках уже есть модули расширения .so их можно тогда закинуть в папку modules на рабочий 
  сервер в этом и преимущество динамических модулей: закинул и подключил без пересборки сервера
   
*/


