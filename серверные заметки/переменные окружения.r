  
  Переменные окружения нужны что бы можно было управлять приложением изменяя значения переменных как через консоль (что не совсем удобно)
  или через файл .env или .env.ci, .env.dev, .env.prod
  Переменные окружения существует несколько уровней.
    Главный уровень - это переменные операционной системы они доступны всем пользователям и всем программам
    Уровень пользователя - каждый зарегистрированный в системе пользователь иможет добавлять свои переменные
                           
    Уровень приложений - переменные устанавливаются программами для каждого пользователя 
                        

  Пример:  Можно задать порт сервера напрямую в файле express.js, а можно указать там где порт
  process.env.PORT и когда мне нужно будет его поменять мне не нужно будет лезть и искать файл и что-то там менять,
  а просто я за ранее буду знать что могу изменить его набрав 
  ИМЯ_ПЕРЕМЕННОЙ=значение node имя-файла.js через консоль или записать в файле
  *ВАЖНО: так можно делать из терминала GitBash. Из PWSH не выйдет
  PORT=8000, а если измениться другой укажу и файлы рыть не нужно будет
  Возможные варианты:
для CMD(Командная строка)
Посмотреть переменные: SET
  SET NODE_ENV=production
  SET NODE_ENV=production & node app.js  работает коряво. 
  Хоть NODE_ENV изменилось node app.js запускаеться со старым значением. && не поможет.

для gitBash
  Посмотреть переменные:  env
  export NODE_ENV=production
  export NODE_ENV=production && node app.js 
  
  Сокращённая версия
  NODE_ENV=production
  NODE_ENV=production node app.js

для PowerShell(PWSH)
  Посмотреть переменные:  ls env: или gci env:  или добавив ...env:*
  Добавить или добавить и запустить
  $env:NODE_ENV="production"  
  $env:NODE_ENV="production"; node app.js 


Эти вариаты можно засунуть в package.json
"scripts": {
  "server": "NODE_ENV=production node server/express.js"
}

Введя данные команды NODE_ENV=production или NODE_ENV=development нам нужно подлкючать файлы или 
.env.production или .env.development можно использовать пакет "dotenv" указав в начале express.js файла

if(process.env.NODE_ENV){
  require('dotenv').config({
    path: `${__dirname}/.env.${process.env.NODE_ENV}`
  })
}else{
  require('dotenv').config(); # если что подключит .env
}

Если надоели .env файлы разбросанные в корне проекта можно закинуть их в папку env.
if(process.env.NODE_ENV){
   require('dotenv').config({ path:  path.resolve('env', `.env.${process.env.NODE_ENV}`) });
}else{
   require('dotenv').config({ path: path.resolve('env', '.env') });
}

Можно использовать вместо "dotenv" использовать пакет "config". Он не используем .env файлы, ему требуется
создать папку с файлами. 

  config
    default.json 
    production.json 

config подхватит production файл если будет введён NODE_ENV=production иначе работает default файл.
"config" показался более комфортным с учётом того что переменные можно не только в json формате описать.
(об этом в доках) да и от проверки можно избавится.




Всё это замечательно но можно пойти дальше и использовать docker запихнув нужные нам сервисы по контейнерам.
Нам не придёться передавать .env файлы с проектом в контейнер, нам не требуеться использовать эти пакеты
мы просто нужные нам .env файлы сразу через docker встраиваем в окружение контейнера передав файлы так:

  env_file: 
    - ./env/dev.env  или  - ./env/prod.env

и мы смокойно можем запускать проект в контейнере без NODE_ENV=... и не строить в коде логику
и мы можем отказаться от логики if(process.env.NODE_ENV){...} ну разве что если мы намеренно хотим видеть
эту переменую в окружении контейнера которую же передаём через docker и в зависимости от её состояния
подключаем куски кода. В docker-compose укажем:
  command: npm run server    предварительно указав в package.json "scripts": {"server": "nodemon --inspect server/express.js"}
  (напрямую command: nodemon --inspect server/express.js работать не будет )

Чем неудобен подход через docker? 

service:
  server-node:
    env_file: 
      - ./env/.env.development
  db:
    env_file: 
      - ./env/.env.development
  ...

Если у нас относительно много сервисов и все нужнаються в переменных, то тут 2 варианта: 
или описывать для всех сервисов в одном файле и тянуть в каждый контейнер нужные и ненужные переменные
(Конечно можно для каждого сервиса насоздавать .env файлы как для production так и для development версии)
или заниматься переписыванием раздела environment под каждый сервис ну и тогда docker-compose.yaml закинуть в .gitignore
Кстате говоря многие контейнеры завязаны на том что бы при запуске мы передавали определённые переменные.
По всей видимости   
  
  
  
Итого: без docker используем пакеты и запускаем:
        NODE_ENV=production && nodemon --inspect server/express.js (в зависимости от консоли строка может чуть измениться)
       с docker можем от них отказатся

[ "nodemon может выдать ошибку: nodemon: The term 'nodemon' is not recognized as a name ...
   нужно установить его глобально npm install -g nodemon" ]


Есть один нюанс с docker. Для некоторого функционала в docker-compose он смотрит на один главный .env файл в корне проекта
и только его мы перемещать не можем если хотим использовать его так: 
  image: nginx:${NGINX_VERSION}, но это только в docker-compose.yaml файле, если нам это не надо и мы просто передаём в контейнер переменные
то без разицы куда мы засунем .env.development или  .env.production главное указать к ним путь через env_file:




Есть ещё способ подключения .env файла через файл launch.json. Я сильно не вникал в него.
Указав "envFile": "${workspaceFolder}/.env" и использовать файл. Конечно можно и в "env": {}
Минусы: vccode могут использовать не все





