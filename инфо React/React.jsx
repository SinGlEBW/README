
/*--О структуре компонентов.. 
Часто методы и свойства хранятся выше по структуре. Зачем?
  1. для того что бы контролировать и обеспечивать разные компоненты одними и теми же методами и свойствами    
  2. оставить более чистые дочерние компоненты
  Передавать данные можно через props и между компонентом в поле children.
  Передавать можно даже компоненты
*/
/*----------------------------------------------------------------------------------------------------
#######-------<{ Стандартные компоненты React }>-------####### */
/* Это JSX формат. Используется в там где возвращается этот формат.  */                   

<React.StrictMode></React.StrictMode>; //следит за ошибками потомков. В случае ошибки предупреждает.
<React.Fragment></React.Fragment>; //пустая обёртка или так <> </> 

/* #######-------<{ React методы }>-------####### */

React.createRef()//присвоим экземпляр будем получать элементам можем получить их свойства
React.createContext();//когда запарило прокидывать пропсы через все компоненты, можно избежать этого использовав данный метод.  

//Было 
class App extends React.Component {
  render = () => <Toolbar theme="dark" />;
}

let Toolbar = (props) => <ThemedButton theme={props.theme} />
  

let ThemedButton = () => React.Component {
  render() {
    return <Button theme={this.props.theme} />;
  }
}
const Context = React.createContext('light');//создание контекста. Принимает defaultValue
<Context.Provider value="dark">  <MyComponent /> </Context.Provider>
// Импортируем Context. 
/* в классовой компоненте можно передать в объект context через contextType */
class newComponent {  static contextType = Context; }//передаём dark
//Общий вариант
<Context.Consumer>{value => { /* value = dark */}}</Context.Consumer>;

const Component3 = (props) => {
  const formikStateAndHelpers = useFormik(props);
  return (
    <Context.Provider value={formikStateAndHelpers} >/*слежка и передача ниже */
      {typeof children === 'function'
        ? children(formikStateAndHelpers)//если родитель передал функцию.
        : children}
    </Context.Provider>
  );
}

/*----------------------------------------------------------------------------------------------------
#######-------<{ Как работает React }>-------####### 
  Отрисовка всей страницы. 1й - основной класс который связывает другие классы, 2й - куда рэндерить*/
ReactDOM.render(<ComponentOne name=''/>, document.getElementById('box'));
/*
  любой компонент может рэндерить html(по сути это готовые компоненты) или другие компоненты.
  Компоненты могут быть классовыми или функциональными.
*/

class ComponentOne extends React.Component{
  render(){
    return (
      <div className="base">
        <ComponentTwo name={this.props.name} left={ <ComponentThree />} right={ <ComponentFour /> }/>
                      
        <h3>Hello {this.props.name}</h3>
        <h4>Параграф</h4>
        {/* скобки что бы указать код который сформирует данные. */}
      </div>
    )
  }
}


//Описание как работает передача через props.children
let Forma = (props) => <div></div>;
<Component> { Forma } </Component>;// передаём не вызванный компонент
<Component> <Forma/> </Component>;// вызвали компонент. Он возвращает спец. объект для React
/*
  В обоих случаях { Forma } <Forma/> мы передаём props.children в Component.
  В спец. объекте так же есть props от компонента вложенного в родителя.

 Спец объект описывает для React что это за данные: Пример: <Component> <div><div/> </Component>;
  {type: 'div', props: {}- пустой} Если есть вложенность <div> <p>15</p> Строка </div>, то 
  {props: { children: [{type: 'p', props:{...}}, 'Строка'] }}.

  Пока { Forma } не вызвана React естественно о ней не знает. Пример:*/

<Component name='Петя'><Forma data={[14,5,17]}/></Component>; //запись в виде JSX, это объект который связан с компонентом и React сам вызовет метод и передаст данные 
<Component name='Вася'>{Forma({data: [14,5,17]})}</Component>; //это почти аналог, сами вызываем, сами передаём, React получает сразу то что возвращает метод. 
<Component name='Вася'>{forma({data: [14,5,17]})}</Component>; //т.к. вызов обычной функции можно создать её с маленькой буквы 
                                                                  
function Component(props) {
  return (<div> Компонент 1 { props.children } </div>)//передаём спец объект от  <Forma...> | Forma() в React 
}
function Forma(props) {
  return (<p>Форма:{props.data[0]}</p>)
}
/*
  Разница между JSX вызовом и вызов функции:
   <Forma data={[14,5,17]}/>     { type: Forma(props), props:{data: [14,5,17]} } - подготовили спец объект с функцией, но вызова ешё не было. 
                                 Что бы вызов произошёл как раз для этого родитель и предаёт объект в React строкой { props.children }
                                 React сам вызовет эту функцию и передаст props. Получается сначала отрабатывает родитель после Forma 
                                                                                 
  { Forma({data: [14,5,17]}) }   { type: <p>, props: {children: ["Форма:", 14]} } - тут мы сами вызвали функцию и передали данные
                                 и получили спец объект возвращаемого элемента <p>. Функция отрабатывает 1й, потом родитель

                                 1. <Component name='Вася'>{Forma({data: [14,5,17]})}</Component>; это
                                 2. <Component name='Вася'><p>Форма:{props.data[0]}</p></Component>;
                                 3. В родителе: { props.children }   
                                 
                                 Лучше возложить это на React а не самому вызывать. React сам решит когда лучше вызвать.


---------------------------------------------------
Можем не вызывать сразу { Forma } а вызвать в родителе props.children() или props.children 
если требуется что ли бо получить в родителе и передать дальше. */
<Component> { Forma } </Component>;//Если будет <Forma > будет ошибка
function Component(props) {
  let newData = {...props, method1: (a) => {}, property: 11 }
  return (
  <div> 
    { props.children({data: newData}) } 
    <props.children data={newData}/>
  </div>) 
}
function Forma(arr) {
  return (<div> Форма: {arr[0]}</div>)
} 



/* Вообще нам не обязательно передавать компонент в родительский компонент, а потом манипулировать через props.children
   Это просто один из способов. Есть же функции которые рассчитывают принимать функции, это просто построения независимой функции. 
   Ни кто там не мешает возвращать сразу компонент без передачи:
   function test1(){...  return test2()}*/

function Component(props) {
  let newData = {...props,method1: (a) => {},property: 11 }
  return (<div> Компонент 1 <Forma data={newData}/></div>)  
}
function Forma(props) {
  return (<div> Форма: {props.data.property}</div>)
}
    

/*1. При использовании JSX не забываем что сначала отрабатывает родитель, а после вложенность. 
  2. Важно так же компоненты указывать с большой буквы если мы используем JSX вызов, иначе React не отработает.
     Так же есть много компонентов которые принимают JSX запись. Во многих случаях не используем такую запись 
     <props.children data={newData}/> так что нет нужды создавать компоненты с маленькой буквы и передавать родителю. 
      
  3. В любом случае компонент переданный между тегов родителя должен возвращаться в React этим родителем.
  4. Лучше не вызывать {Forma()} а предоставить это обрабатывать React.

*/


/*----------------------------------------------------------------------------------------------------
#######-------<{ Некоторые фишки и рекомендации }>-------####### */

arr.map((item) => (/*При итерации можем передать что-нибудь в событие*/ 
  <div onClick={(e)=>{ this.evChange(e, item.number) }}>item.number</div>
));
//
arr.map((item, inx) => (/*Привязать index и в случае чего удалят по нему*/ 
  <div onClick={(e)=>{ this.myRemove(e, inx) }}>item.number</div>
));

/*----------------------------------------------------------------------------------------------------
#######-------<{ Наследованные методы и методы React }>-------####### */

render()//обновляется в 1ю очередь при изменении компонента и первоначальной загрузки страницы
componentDidMount()//отрабатывает после render 1 раз, то есть после того как DOM отрисовался 
componentDidUpdate(prevProps, prevState)//обновляется после render и только если были изменения компонента 

React.createRef()//присвоим экземпляр будем получать элементам можем получить их свойства






"-----------------------------------------------------------------------"
"#########-------<{ Объект события React }>-------#########"
onFocus//реагирует при фокусировке на элементе
/* свойства и методы класса event */
/*
  В React над обычным объектом Event есть обёртка SyntheticEvent которая при вызове события 
  передаёт данные в event и очищается. (сделано это дял производительности. Поэтому я ничего там
  не видел, только после вызова). Что бы исключить этот объект из потока и использовать асинхронно
  нужно вызвать e.persist()
*/
e.bubbles//является ли событие всплывающим в DOM :=> bool
e.cancelable//является ли событие отменяемым :=> bool
e.charCode//хз но вместо кода клавиши возвращает 0
e.ctrlKey//был ли нажат Ctrl
e.shiftKey//был ли нажат Shift

e.currentTarget//target тот на котором висит событие. Не важно если кликаем на дочерний элемент
e.target//если событие на родителе, то в target попадает тот элемент на который тыкнули
e.defaultPrevented//информирует был ли в событии установлен e.preventDefault() :=> bool
e.detail//возвращает число кликов по событию. Клики засчитываются если интервал чуть меньше секунды иначе сбрасывается 
e.dispatchConfig//описывает что за событие отработало
e.eventPhase//возвращает число типа event: Ev.NONE = 0 Ev.CAPTURING_PHASE = 1 Ev.AT_TARGET = 2 Ev.BUBBLING_PHASE = 3
e.getModifierState("Shift")//была ли нажата. На всю клавиатуру не распространяется, только определённые кнопки. читать Modifier keys on Gecko
e.keyCode || e.which //определяют код клавиши 
e.type//определяет чем нажато. Смысла от этого нет т.к. я определяю событиями мыши или клавы 
e.timeStamp//показывает число в промежутке времени котором было отработано событие
e.nativeEvent//js нативный event


/*
    Пропускаем по 2м линкам внутри Component1 проверяем линки и подгружаем нужный
    компонент
  <Route path={['/', '/login']} component={Component1}></Route>
 */
//setState в render и componentDidUpdate использовать можно только в условии которое ограничит и не даст бесконечно перерисовывать компонент 

"-----------------------------------------------------------------------"
"#########-------<{ стандартные props для компонентов }>-------#########"

/*
Заметка
  Иногда при построении сайтов предусматривают вариант для людей с ограниченными возможностями
  Когда проектируются такие решения нужно использовать не camelCase а kebab-case.
  В React есть атрибут aria-* и целый список возможностей. 
*/
component='div'; /*или*/ component={myComponent};
<Parent render={() => <Component/> } />;
<Parent component={() => <Component/> } component={Component} component='div' />;
<Parent children={ <Component/> } />;
<Parent><Component/></Parent>;





/*
    Информация

    С версии 17.0 : Удалят componentWillMount, componentWillReceivePropsи componentWillUpdate. 
    (С этого момента будут работать только новые имена жизненного цикла с префиксом«UNSAFE_».)
*/