/* eslint-disable */
let str = 'loginLink=Hello&passwordLink=Word';
str.match(/loginLink/g);//возвращает все найденные элементы в виде массива. Array
str.split(separator/regexp, limit);//разбивает строку на массив по сепаратору
str.includes('loginLink', 2);//ищет с начала. 2й пар. делает сдвиг с начала. если находит кусок возвращает bool
str.endsWith('loginLink', 2);//ищет с конца. 2й пар. делает сдвиг с конца. возвращает bool
str.startsWith('loginLink')//ищет в начале

str.lastIndexOf('o');//возвращает индекс последнего найденного элемента
str.repeat(2);//повторит строку 2 раза
str.concat();//соединяет минимум 2 строки и возвращает строку
str.replace(regexp|substr, newSubStr|function(){});//что найти, на что заменить. Возвращает обратно строку
str.indexOf('Hello');//возвращает индекс 1го вхождения. 
str.search('Hello');//возвращает индекс 1го вхождения. Принимает так же рег.выр. 
str.slice(0, 10);//откуда, покуда обрезать строку принимает индекс. 
str.substr(0, 10);//Это старый вариант как и substring одно и то же. Новый slice 
str.charAt(5);//возвращает символ по данному индексу. Естественно тип строка
str.toLowerCase();//приводит в нижний регистр
str.toUpperCase()//приводит в верхний регистр
str.trim();//обрезает пробелы
//Это экспериментальная технология
str.padStart(10, "этим");//чем заполнить первые 10 ячеек данной строки
str.padEnd(10, "дополним");//строка входит в учёт 1го параметра, если что-то останется от 10ти, то 2й пар дополнит строку
String.raw({ raw: "Hello" }, 1, 2, 3);  // "H1e2l3lo"

/*--------------------------------------------------------------------------------------------------------------------------------------------*/

Math.ceil() //сократить в большую сторону
Math.floor() //сократить в меньшею сторону
Math.round()//сокращает до ближайшего целого
Math.max() //возвращает наибольшее число из приложенных аргументов. Массив не принимает
Math.min() //возвращает наименьшее число из приложенных аргументов. Массив не принимает
Math.max.apply(null, [343,454,23,21])//массив так можно передать
Math.abs('-3')//преобразует числа строки в number и положительное.Одно число в Math.abs([2]) [] -опустит
Math.pow(7, 2);// 7 во 2й степени
Math.sqrt(9);// возвращает корень числа
Math.random()//рандомное значение от 0 до 1
Math.sin()//возвращает синус числа 
Math.cos()//возвращает косинус числа
Math.tan()//возвращает тангенс числа
/*--------------------------------------------------------------------------------------------------------------------------------------------*/
let num = 123.44445
num.toFixed(3)//ограничивает число после точки и возвращает тип String
Number.toString();
/*--------------------------------------------------------------------------------------------------------------------------------------------*/
let arr = [10, 20, 30, 40, 50, 60, 70, 80];
/*
 Все методы которые могут получить старый массив и вернуть такой же, но новый это и есть возможность 
 скопировать. map, Array.from, filter, оператор spread, и т.д
*/
//3 способа разбить строку
Array.from('Привет')//принимает строку или итератор. Возвращает новый массив.
'Привет'.split('')
([...'Привет'])

//не меняет основной массив.
arr.concat();//склеивает 2 и более массивов. <- новый массив.
arr.slice();//обрезать массив (как и в string) Откуда,покуда(включительно). <- новый массив не изменяя основной

arr.join();//склеивает массив в строку. Принимает разделитель 
arr.toString();//тот же join но без сепаратора

arr.indexOf(inx);//тот же принцип как и в string. <- index значения. -1 нет значения.
arr.includes();//есть ли в массиве искомая строка. <- bool

arr.reverse();//переворачивает массив
arr.flat();//убирает вложенность массивов [23,[43,22]] - [23,43,22]. Принимает число на сколько уровней поднять

//меняет основной массив.
arr.pop(inx);//удаление в конце массива. <- вырезанное значение.
arr.push();//добавление в конце массива. <- длину массива
arr.shift(inx);//удаление в начале массива. <- вырезанное значение.
arr.unshift();//добавление в начале массива. <- длину массива

arr.splice(1,4, 'ss');
/*
  тот же slice но изменяет основной массив и может внести изменения в основной массив вместо вырезанного куска.
    Основной массив будет выглядеть:
    [10, 'ss', 60, 70, 80] //arr   
*/

arr.copyWithin(1, 8, 11)// копирует значения индексов и перезаписывает в нужную позицию. <- новый массив, меняет старый.
   /* 1й inx - с какого индекса класть копию, 
      
      2й с какого индекса (включительно) копировать
      3й до какого (не включительно). Не обязательный.

      [11,10,9,17,14,13,26,37, 42, 15, 24, 62,71,85] //было
      [11, 42, 15, 24, 14,13,26,37,42,15,24,62,71,85] //стало
   */

arr.fill(100, 6, 7);//перезаписать значением 100 от и до индекса. 
  /* [11, 10, 9, 17, 14, 13, 100, 37, 42, 15, 24, 62, 71,85] 
    Не указав 3й аргумент, заполнит массив до конца моим значением.
  */




/**######--Переборы--######## */
arr.forEach(()=>{});//цикл
arr.map((val, inx, _this)=>{});//тот же forEach только <- новый массив  
Array.from(arr, (val,inx) => {})//90% тот же map, чуть другой подход и callback без 3го аргумента
//если map или from указать логические выражения, то вернётся массив с bool значениями 

arr.every((item) => item < 40)//проверяет каждый элемент на соответствие условию. Не соответствие - false и прекращает итерацию. 
                              //при приведении к типу Boolean (item === 'строка'), хоть она будет и ровна every вернёт false
arr.some((item) => (item === 60))//<bool. проверяет выражение. прекращает итерации когда найдёт совпадение возвратив true
arr.find((item) => (item > 60));//возвращает найденный в массиве элемент
arr.findIndex((item) => (item === 60));//возвращает индекс найденного элемента

arr.filter((item) => item > 30);//исключает элементы и вернёт новый массив не трогая старый
//sort по ум. работает с каждым эл. как со строкой. кастомный вариантом определяем как числовое выражение
arr.sort((value1, value2)=> (value2 - value1));//от большего к меньшему, наоборот value1 - value2
//возвращает новый сортированный массив, так же изменяет основной. 

arr.reduce((preventValue, item) => (preventValue + item), total);//на основе своего инструмента может преобразовывать один тип в другой. 
//Например работать с массивом и вернуть объект
//Пример
/*
  ПРОЧИТАТЬ. 
  Всё что нужно знать это то, что reduce это обычный цикл, передав reduce 2му параметру начальное значение
  мы в callback во 2м параметре получаем перебор цикла от с 1элемента и до конца,
  Если не передать total, во 2й параметр callback'a цикл массива начинается
  со 2 элемента массива и цикл будет на одну итерацию меньше. 
  Так что лучше всегда предавать, что бы не было путаницы
  
  1й же параметр получает total если он есть, если нет то получает 1й элемент массива
  при первой итерации, а далее параметр ожидает изменения над ним на каждой итерации 
  и возврат этих изменений. 1й параметр как бы сохраняет изменения на итерации и передаётся 
  в следующую итерацию для дальнейших изменений. В конечном итоге после всех изменений
  возвращается reduce именно этот параметр.
  Если ничего не вернуть, то ничего и не будет. А если вернуть, 1й параметр
  работает как бы с запозданием на 1 итерацию 

  3й параметр это индексы
  ВАЖНО reduce не привязан к определённому типу возвращаемых данных.
  Что должен вернуть метод определяет программист.
  На основе массива можно вернуть объект 
  */
const arr1 = [{ test: [1] }, { test2: [2] }, { test3: [3] }];

arr1.reduce((a, b) => ({...a,...b}), {});
//из 2х массивов объект
let arr3 =  ['a', 'b', 'c'];//ключи
let arr4 = [7, 2, 5];//значения

arr3.reduce((acc, n, i) => (acc[n] = arr4[i], acc), {});//{a: 7, b: 2, c: 5}

/*
   Зная что acc на 1й итерации это пустой объект, а n это 1й элемент массива,
   и зная о том что свойства можно создавать обращаясь к объекту просто через точку
   и через синтаксис массива, то нам нужно на каждой итерации создавать разные свойства
   а не одно и тоже поэтому поэтому обращение через []. Возвращаем acc
*/

//Сложный вариант для понимания. Массив что-то типа ключ - значение
let arr2 = [ "test", 16 , "test2", 2 ,"test3", 3 ];
//(!(c%2)) - 0%2 = 0, 1%2 = 1, для if 0 = false поэтому !0 = true и получаем чётные цифры


let ob1 = arr2.reduce((a, item, inx, _this) => { 
    
  if(!(inx%2))
     a[item] = _this[inx+1]
  
  return a
}, {});

//сократить
let ob2 = arr2.reduce((a, item, inx, _this) => (
  (!(inx%2))?a[item] = _this[inx+1] : null, a), {});
console.dir(ob1);

/*
  Массив нужно разбить на чётные(ключи) и нечётные(значения) для этого нужно делить 
  с остатком на 2 и получать будем 0 и 1. Ключи будут отмечаться 0, 0 = false 
  значит !false. 
  Берём объект создаём свойство через ключ и чтоб присвоить значение(а в этой итерации его нет)
  обращаемся через 4й параметр this и выбираем тот индекс в котором находимся + 1,
  то есть следующее значение массива.  
*/

/*--------------------------------------------------------------------------------------------------------------------------------------------*/

let ob = { name: 'Вася', age: 27};//создание обычного объекта.
// вариант для гибкой настройки объекта. Имеет дескрипторы настройки. Есть и отдельный вариант дескриптора.
let ob2 = Object.create({методы},{свойства});//методы в prototype попадают

//Пример:
let ob2 = Object.create(
  {
    method(){},
    ...myOb.prototype//можно копирнуть из другова объекта методы
  },
  {
    name: {
      //по ум. все дескрипторы в таком объекте стоят в false
      value: 'Вася',
      enumerable: true,//при итерации данного объекта разрешает получать key
      writable: true, //разрешает изменять значение объекта
      configurable: true,//разрешает удалять свойство из объекта. delete ob2.name
    },
    age: {
      value: 1992
    },
    //обратившись к get можем брать значения объекта, обработать их и вернуть результат как свойство.
    getAge: {
      get(){
        return new Date().getFullYear() - this.age
      }
    },
    //в set так напрямую можно получать значения и вернуть результат.
    setAge: {
      set(value){
        //можно взаимодействовать с элементами. Изменив свойство изменим цвет.
        document.body.style.background = '#000';
      }
    }
  })




let copyOb = Object.assign({}, obg, ...ob)//ES5. копирует объект. Можно в 1й арг. кинуть не пустой объект, тогда скопирует ещё и в него.
                                          //Symbol так же копирует
let obj2 = {...obj1};//ES6


let obj = {
    name: 'Alex',
    age: 21,
    city: 'NewYork',
    number: 15,
    [Symbol('foo')]: 'Антон',//такое свойство не изменить
    get _number(){  return this.number  },
    set _number(value){
      if(value > 0 && value <= 20)
        this.number = value 
      else{
        let strErr = (value < 0)? 'Меньше: 0' : 'Больше: 20';
        console.dir(strErr);
      } 
    }
}



/*что бы нельзя было напрямую что то менять в объекте есть defineProperty*/
Object.defineProperty(obj, 'имя свойства', {
    enumerable: true,//по.ум false. при итерации данного объекта разрешает получать key
    writable: true, //по.ум false. разрешает изменять значение объекта
    configurable: true,//по.ум false. разрешает удалять свойство из объекта. delete ob2.name
    value: 'Борис',//значение свойства
  });

/* НЕДОСТАТОК. метод на 1 свойство */

//для многих свойств
Object.defineProperties(obj, { 
  key1: {
    enumerable: false,
    configurable: false,
    writable: false,
    value: 'Борис'
    },
  key2: {
    enumerable: false,
    configurable: false,
    writable: false,
    value: 'Петя'
  }
});

Object.freeze(obj);//замораживает объект, устанавливая дескрипторы configurable и writable в false.

let dest = Object.getOwnPropertyDescriptor(obj, 'name1');//узнаёт состояние дескрипторов


 Object.values({key: 'values'}) //получить все значения ключей и вернуть итератор
 Object.keys({key: 'values'}) //получить все ключи и вернуть итератор
 Object.getOwnPropertyNames(obj)//<arr. вернёт массив ключей объекта


obj.hasOwnProperty('name');//<bool. если есть ключ. Показывает в тех объектах которые в консоли (без console.dir)
                           // отображаются как объект а не как html структура
                           

let obj = {name: 'вася', age: 16};
//не уверен, но вроде in работает в цикле for in

if('name' in obg){} // оператор in в данном случае вернёт bool если есть ключ

 /*
   *********** Общие методы не привязанные к объектам **********
 */
 

 parseFloat('4ffffeeee');//<Number. обрезает буквы после числа. Если 1е не число вернёт NaN 
 parseInt('')//тоже обрезает, но число будет целое



/*######------<{ Тесты скорости методов }>------######*/

let state = {
  inputName: { min: 2, max: 15, status: true },
  inputPhone: { min: 18, max: 18, status: false },
  textArea: { min: 10, max: 400, status: true },
};


console.time()
for(let key in state){
  if(state[key].status){
    console.dir(1);
  }
};
console.timeEnd()//0.279296875 ms

console.time()
if(Object.values(state).every((item) => item.status)){
  console.dir(2);
}
console.timeEnd()//0.02490234375 ms


/*########-------<{ Ошибки }>--------#########*/
/*
  Аргументы через { } можно прочитать, но вносить изменения и надеяться что они передадутся
  в объект, нет смысла. Этого не произойдёт.
  Если хотим сохранять данные то передавать объект. (el)
*/
function maxMin({ name, value }){//передаём this element из DOM

  let stateItem = state[name];
  stateItem.length = value.length;
  stateItem.value = value;

  if(value.length >= stateItem.min && value.length <= stateItem.max){
    stateItem.status = true;
  }else{
    stateItem.status = false;
  }
  if(value.length > stateItem.max){
    value = value.slice(0, stateItem.max)//value не передаст значение элементу
  }
}
