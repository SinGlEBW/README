<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Фильтры</title>
</head>
<body>
<!--  Главное что нужно уяснить что css фильтры удобней использовать, но ограничены по сравнению с svg фильтрами.
      Если достаточно css, то можно не усложнять.

    1. Фильтры имеют свой размер называется "bbox". filter по умолчанию 
       ("bbox") x="-10%" y="-10%" width="120%" height="120%" filterUnits="objectBoundingBox"
        можно убедиться если подвигать изображение через feOffset dx dy
    2. Если попробовать через feOffset использовать позицию x/y то картинка будет обрезается по этим сторонам.
    3. Когда накладываем фильтр на объект нужно иногда расширять "bbox" что бы не было видно как края фильтра
       обрезаются
    4.  т.к. при сдвиге "bbox" изображение обрезается, можно через feComposite вызвать оригинал и фильтр и получить 
        пол изображения чистого и с фильтром. 
    5. Что бы узнать края "bbox" нужно использовать фильтр feFloor. Он зальёт область фильтра целиком.
    6. Каждый атрибут result перетекает в in следующего фильтра если не было явного указания последовательности
    7. result предыдущего feComposite не передаётся на вход следующего feComposite
###########-----------<{ атрибут in и result }>----------#############

      Указанные фильтры между тегом filter называют примитивами. 
      Почти каждый фильтр имеет один или два атрибута in(in2) и атрибут result.

      in - может быть один из 6 основных свойств:
          "BackgroundAlpha", "BackgroundImage","FillPaint","SourceAlpha","SourceGraphic", "StrokePaint"
          или строкой которая была определена в предыдущем фильтре в атрибуте result.
      Если в in ничего не будет передано, то result предыдущего фильтра автоматически передаётся на вход
     

      "SourceGraphic" - говорю, получить изображение к которому подключён фильтр
      "SourceAlpha" - тот же SourceGraphic, только получает альфа канал изображения.Чёрный квадратом размером с
                      объект на котором фильтр
                      
      "BackgroundImage" - говорю что под фильтром есть изображение
      "BackgroundAlpha" - альфа канал
      "FillPaint" - ключевое слово для управления fill на объекте через фильтр
      "StrokePaint" - ключевое слово для управления stroke на объекте через фильтр

      "Иногда захочу использовать графику в качестве фильтра, а иногда только её альфа канал(то есть прозрачность)"


      Если не указать result примитива, то его result автоматически передастся на вход следующего 
      примитива фильтра

------------------------------------------------------------------------------------------------>

    <feGaussianBlur  stdDeviation="" edgeMode="duplicate|wrap|none"/>
    <!-- stdDeviation="number" - размытие. если задать 2 числа то 1й по X 2й по Y размывает
         edgeMode - этот аттрибут так же использует <feConvolveMatrix>/ определяет , как расширить входное изображение по мере необходимости 
                    пока не понятно как работает -->
     
    <feFlood flood-color="#EB0066" flood-opacity=".5" result="MY_FLOOD"/> <!-- фильтр буквально заливает "bbox" всё цветом.  -->
    <!-- flood-opacity - т.к. фильтр заливает всё цветом, то под ним не будет объекта к которому применили фильтр
                         нужно воспользоваться дополнительным фильтром feMerge  -->

    <!-- Свойство управляет последовательностью фильтров. Просто z-index последовательность.
         Наглядно, большой объект видно под маленьким. -->
    <feMerge><!-- Сам feMerge не имеет in, но его элементы feMergeNode имеют. Пример как использовать in result -->
      <feMergeNode in="MY_FLOOD"/><!-- можно опустить in здесь и result предыдущего т.к. они идут друг за другом -->
      <feMergeNode in="SourceGraphic"/><!-- Получить объект к которому подключили filter -->
      <!-- последний feMergeNode это самый верхний по z-index элемент -->
    </feMerge>   

    <feComposite in="" in2="" operator="atop" k1="" k2="" k3="" k4=""/><!-- Похоже на feMerge но нет -->
    <!-- Чаще всего фильтры видно как выходят за пределы графики, но хотелось бы что бы они были в ней. Уменьшать "bbox"
         не вариант, резкое обрезание фильтра. Последовательность так же не решает этот вопрос. 
      Фильтр feComposite в отличие от feMerge складывает эффекты друг с другом, работает с альфа каналом, можно вкладывать источники света.
operator{
    over - графика, определенная в атрибуте in, помещается поверх,графики определенной в атрибуте in2.
    in - значение указывает, что исходная графика, определенная в атрибуте in, перекроет графику размером, определенную в атрибуте in2..
    out - части графики, определенные в атрибуте in, которые выходят за пределы графики, определенной в атрибуте in2, будут отображаться.
    atop - работает вроде так же как in
    xor - написано что объединяется основная графика in in2. хотя работает вроде как out 
    lighter - ....
    arithmetic - in и in2 объединяются с использованием формулы k1*i1*i2 + k2*i1 + k3*i2 + k4 где i1- пиксели от in, i2- от in2
                  и связанно это вроде как со светом <feDiffuseLighting> и <feSpecularLighting>
}
 
      
      
      -->
<!--#########--------<{ Фильтры освещения. }>---------###########-->
<!--  Сам по себе не работает нужен fePointLight-->
<!-- Более грубое рассеивание -->
    <feDiffuseLighting in="" result="" lighting-color="">
      <fePointLight x="50" y="75" z="200"/><!-- определяет источник света. Используется в feDiffuseLighting и feSpecularLighting -->
    </feDiffuseLighting>

    <!--
      surfaceScale="" - уменьшает масштаб точки и света
      diffuseConstant="12"- масштаб точки света.
      kernelUnitLength -функция не рекомендуется. удалена, но некоторые браузеры могут до сих пор поддерживать
    -->
  <!-- Более плавное рассеивание чуть расширенный функционал  -->
    <feSpecularLighting in=""  specularConstant="12" lighting-color="">
      <fePointLight x="50" y="75" z="200"/>  <!-- располагает источник света. z - меньше, точка дальше.  -->
    </feSpecularLighting>
  <!-- 
    Фильтр работает с альфа каналом.
    surface Scale="" - уменьшает масштаб точки и света
    specularConstant="12" - масштаб точки света.
    specularExponent="10" - распространение источника света. число больше - пучок света меньше.
    lighting-color="" хз, но об этом атрибуте не упоминается в дос. Задаёт цвет света.
    kernelUnitLength - функция не рекомендуется. удалена, но некоторые браузеры могут до сих пор поддерживать
  -->

    <feTurbulence baseFrequency="0.1 0.1" numOctaves="2" seed="3" stitchTiles="" type=""/>
    <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="50" xChannelSelector="R" yChannelSelector="G"/>
    
    <feBlend  in="SourceGraphic" in2="" mode=""/><!-- тот же mix-blend-mode. ток чёт фильтры не все показывает -->
    <feImage xlink:href=""/><!-- подключение изображения в фильтре.  -->
</body>
</html>