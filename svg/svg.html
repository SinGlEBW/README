<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="./img/favicon.ico" type="image/x-icon">
  <link rel="stylesheet" href="./css/normalize.css">
  <!-- <link rel="stylesheet" href="./css/directedSlider.css"> -->
  <!-- <link rel="stylesheet" href="./css/cyclingEl.css"> -->
  <!-- <link rel="stylesheet" href="./css/original.css"> -->
</head>
  <body>


<!-- 
Элементы описанные тут работают в пределах тега svg 
  Подключение svg осуществляется обычно через object если требуется достучаться из вне
  через файл css нужно указать в начале svg -->
  <?xml-stylesheet type="text/css" href="../css/style.min.css"?>  
<!--
Обратиться через object не получиться т.к. любые object > svg на самом деле смотрят что у него между тегами,
а не внутри object и так же задавая свойства в object не приведёт к результату,
но уже сами классы из svg можно писать в css

  0. svg фильтры можно применять и к html блокам
  1. svg это контейнер для построения векторной графики.
  2. svg не привязан к пикселям поэтому расширяется и не теряет качество 
  3. svg - это элемент inline-block и имеет разрешение 300х150 
  4. В svg может быть объект svg.
  5. svg построен на xml языке. по ум. 
  6. объекты в svg привязаны к координатной сетки угла блока svg. Вспомогательные элементы(теги) имеют атрибуты с префиксом *Units установив которые можно перенести сетку
     от угла объекта в svg блоке. Например: в <linearGradient  gradientUnits="userSpaceOnUse" - от угла svg "objectBoundingBox" - от угла фигуры >
     При использовании transform, rotate это нужно учитывать. Оба свойства работают с % как обычно, но userSpaceOnUse работает ещё от 0 до 1, а objectBoundingBox может 
     указываться в px
  7. именно svg стили заданные в css перебивают стили svg заданные через html. Стандартные css стили кроме некоторых имеют в html выше приоритет
  8. svg фигуры (объекты) не имеют ни каких border: 1px solid black; 
  9. ни <g> ни <path> не имеет свойств управляющих размером. Читать о <path> ниже
  10. Подключение в css через url() любых svg вспомогательных элементов (например linearGradient) не получиться анимировать
  11. Что бы image влезло целиком и полностью, любого размера блока svg, размер image должен совпадать с viewBox 
  12. Если для textPath имеется путь, но не соответствует нашему viewBox, то придётся помещать в <symbol> как path так и textPath и вызывать через use   
  13. Не смотря на то что rect можно использовать как блочный элемент погружая туда элемент image картинки не будет, в svg всё определяется последовательностью
      и позиционированием
  14. svg имеет наследование свойств. fill на svg это не фон блока svg а закраска его элементов если они есть. svg фон background-color  
  15. Когда установлен viewBox именно свойство на имяДопЭлемента*ContentUnits не работает
  16. При подключении svg через img и установив svg border, то увидим как левая и нижняя часть border скрыты блоком img
-->


<!--#####----------<{ Основные атрибуты для блока svg }>----------#####-->

<!-- 
 <{  Некоторое отступление  }>
В html есть такое понятие viewport это окно просмотра в блоке (например div) которое управляется атрибутами width и height
всё что погружается туда видит пользователь, на самом деле погружается на холст. Позиция холста и его размер не трогается, 
в случае с любыми тегами кроме svg, изменяются лишь объекты и viewport. Когда объекты выходят за пределы viewport (то есть блока)
можно скрыть overflow: hidden; или в случае с картинкой указать ей что бы она принимала размеры именно такие какие имеет блок. 

В svg этим холстом дополнительно можно управлять, отдаляя и перемещая его относительно viewport 
ViewBox = "x, y, width, height". 
Если не указывать ViewBox то холст растягивается на размер svg то есть на размер viewPort и работает всё как обычно,
увеличивая viewPort расширяем пространство рабочего поля, то есть холста, но не изменяем размер холста и не двигаем его.


Подключив изображение к image оно имеет свои размеры и не обязательно должно заполнить элемент image. Отследить можно если заполнить
image элементом rect. 


По ум.  x y привязаны к верхнему углу блока viewport svg, но можно холст двигать
            задавая холсту width и height он всегда пытается подстроиться под размер (viewport) блока svg
            и если мы уменьшаем размер ViewBox то он растягивается на viewport создаться впечатление увеличения изображение, увеличиваем размер,
            изображение пытается втиснуться в viewport и эффект уменьшения  -->


<!-- Атрибуты закраски установленные на svg блок будут воздействовать на все элементы. Можно применять отдельно на тегах
    Свойства так же можно указывать через css но только в том случае если файл svg имеет кодовую структуру, а не подключение отдельного файла
    css свойства на файле имеют наивысший приоритет
-->

<svg viewBox="-80 -80 160 160" style="display: block; width: 100px; height:100px; border: 1px solid #000;" >
  <!-- Здесь говорим: (Предположим есть элемент circle)
    На ширину блока svg 100px на 100px, имеем элемент circle. Который так нарисован на холсте из-за своих путей имеет большую форму.
    Уменьшая и увеличивая сам блок svg, элемент не меняя ни на пиксель своего местоположения, увеличивается и уменьшается вместе с блоком 
    будто в лупу увеличили. 
    Методом подбора выставим отдалим его на 160 попугаев назад. Лучше отдалять не резко что бы из виду не потерять элемент т.к. холст 
    отдаляем не только в глубь по z но и "x" "y" тоже смещаются. 
    Далее выравниваем элемент если это нам надо по центру svg и забываем про какое либо центрирование т.к. его от центровать нужно 1 раз. 
    Остальное какое либо центрирование на странице осуществляется объекта svg осуществляется путём css. Уменьшая увеличивая блок svg 
    элемент никуда не девается.    

  -->
</svg>

<!--------------------------------------------------------------------------------------->
<!--#####----------<{ Основные элементы svg и их атрибуты }>----------#####-->
<!--  не имеют свойств width height -->
  <circle  cx="100" cy="50" ry="50"/> - <!-- круг. имеет так же закрывающий тег. cx cy - центр круга, ry - радиус, x y - смещение -->
  <ellipse cx="100" cy="50" rx="100" ry="50" /> - <!-- овал. -->
  <rect x="" y="" width=""  height="" rx="" ry=""></rect>  <!-- местоположение квадрата и размер и возможный радиус. При попытке спрятать fill и использовать stroke-width
    можно увидеть смещение квадрата относительно рамки. Поправить нужно подвигать через x y квадрат. Что-то связано в viewBox на будущее узнать.-->
  <line x1="20" y1="20" x2="50" y2="50" stroke="gray" stroke-width="5" ></line> <!-- Имеет начало конец. Не имеет fill это ж линия, только толщина линии и всё что с ней связано -->
  <polyline points="50 50, 100 100, 200 300" stroke="gray" stroke-width="5"/> <!-- Заменяет кучу тегов line. принимает кучу точек и соединяет их-->
  <polygon points="50 50, 100 100, 200 300" stroke="gray" stroke-width="5"/> <!-- отличается от polyline тем что последняя линия stroke смыкается с начальной линией -->
  <path d="" fill="" stroke="" stroke-width="" />   <!-- О path ниже. Вкратце самый универсальный инструмент -->
 
  <image xlink:href="" x="" y="" height="" width=""/><!-- Изображение растягивается пропорционально по ширине ('эффект contain) что бы менять не пропорционально на image или svg добавить preserveAspectRatio="none" 
    Так же из-за того что изображение может занимать не полностью контейнер svg. При рисовании или вырезании
    по ум. всё происходит от верхнего левого угла и может задеть лишь часть изображения. Даже
   
    1. На image не работает fill="" stroke="" stroke-width="" и даже border

  -->
  <text x="0"  y="0" textLength="1920"></text><!-- так же зависит от viewBox. цвет текста через fill -->

  <text>
    <tspan></tspan><!-- обычный span на уровне svg. просто для оформить отдельный кусок текста  -->
    <textPath xlink:href="#myPath">
      Текст будет расположен по подключённому пути 
    </textPath>
  </text>
<!--#####----------<{ Доп элементы }>----------#####-->
  <g></g> <!-- Требуется для группировки тегов path. Не имеет стилей -->
  <defs></defs> <!-- - definitions — определения -->

<!-- Пример с выравниванием текста -->
  <g class="step3">
    <path d="M374.4,50.052l86.5-49,86.5,50v100l-86.8,50.6-86.4-49.9Z"/>
    <text transform="translate(429.383 75.049)">ШАГ <tspan class="l" x="50.516" y="0">3</tspan></text>
    <text transform="translate(418.676 103.299)">Выполнение
      <tspan x='-22' y="17" text-anchor="start">электро - монтажных</tspan>
      <tspan x="23.317" y="34">работ</tspan>
    </text>
  </g>
<!-- 
  Как выравнивать текст в svg. Только посредством координат и атрибутов svg. Что бы перенести текст
  в предложении придётся оборачивать текст в tspan или text для того что бы воспользоваться координатой 
  "y" т.к. перенос осуществляется по координатной сетке. Опустив слово, нужно будет сдвигать по x. 
  x="0" в теге <tspan> это нулевая координата <text>. Это нужно понимать, что бы понять как работает атрибут


  <tspan>
  text-anchor - Мы говорим: Текст ты сейчас на x="-22" и относительно этой точки, я привяжу её к твоей середине
                тем самым сдвинув тебя на половину в лева.
  x - смещение от сетки родителя. Например привязали к родителю x='10'
  dx - смещение от места положения элемента. x='10', а dx движение от 0. Даже если был бы x='0', dx всегда от местоположения.
  -->

<!-- 

   #<{ общие атрибуты }>#
  fill="gray" заливка
  stroke="red" заливка border
  stroke-width="20" - типа линии (border). Обводка на фигуре сидит своей серединой, а не внутренним краем.  Увеличивая её толщину половина 
                      от рисовывается во внутрь, другая наружу. Можно указать толщину в 2 раза больше радиуса, тогда круг будет закрыт этой линией полностью,
                      но если продолжить увеличивать её размер т.к. круг внутри сомкнулся линия начнёт делать расширение наружу открывая круг. 
                      Интересного эффекта можно добиться с stroke-dasharray после того как линии полностью сомкнулись внутри разделив линию на промежутки получим что-то
                      типа колеса от мельницы. Увеличив ширину увидим как линии будут баговано себя вести особенно в анимации. 
  x y - положение объекта относительно svg холста. у окружности cx cy
  fill-rule="nonzero" имеет пару свойств. заливает определённые участки в сложных фигурах, где фигура пересекает себя
  transform="rotate(20)"

 #<{ атрибуты линий }>#
ВАЖНО: Сразу не заметил, stroke-dasharray спокойно разделяет stroke линию вокруг основных фигур. 
  stroke-linecap - стиль для закругления концов линии: butt -как есть линия, round -прибавляет 50% ширины линии и закругляет, square - 50% 
  stroke-dasharray - разделяет линию на, кусок линии и пробел и так поочереди. 1 арг. длина линия, 2й длина пробела.
                     можно задать 3й опять длину линии. Цикл будет повторять снова и снова и 1й аргумент тогда будет отвечать то за пробел, то за линию

  stroke-dashoffset - свойство смещает вдоль линии этот штрих который сформировали через dasharray. Таким образом можно 
											подогнать рисунок на нужный участок линии. Или если заставить это число изменяться получиться анимация 
                      движения линии. Работает только с dasharray
                      
#<{ атрибуты text и индивидуальные для textPath  }>#
  x="10 80 150" 
  y="10 80 150"  - интересно то что в тексте можно указывать несколько значений и смещение будет работать для каждой буквы
  textLength="1920" - текст растягивается на нужную ширину. Пример viewBox="0 0 1920 1080" добавляя меж буквенные интервалы типа letter-spacing как в css, 
                      но только работает это как контейнер. Если не указать, то текст будет занимать столько сколько ему надо. 
  lengthAdjust="spacingAndGlyphs" - По ум. spacing. применив textLength можем получить большие пробелы, но текст будет на весь контейнер, это свойство растянет буквы заполняя 
                                    пробелы. 
  text-anchor="start" - свойство переносит точку за которую двигаем объекты относительно svg. Обычно это левый верхний угол, с текстом это левый край, с кругом это центр. 
                        Можно указать middle или end или забыть этот атрибут. Даже transform="rotate(45)" Всё равно продолжает вращать относительно края при middle.   
  font-size="230px" - зависит от viewBox поэтому может быть задано большое число. Придётся на глаз настраивать.  

для textPath
  startOffset="200px" - устанавливает отступ для текста на линии привязанного пути 
-->



<!--------------------------------------------------------------------------------------->
<!--#####----------<{ Как не нужно писать }>----------#####-->
  <!-- Не верный вариант -->
  <svg xmlns="http://www.w3.org/2000/svg" width="100px" viewBox="0 0 511 511">
    <rect x="50%" y="50%" width="100" height="100" style=""/>
    <svg id="hoverCircle" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 57 58.523">
    <!-- путь формы круга. Оборачивает родительский квадрат. Лучше так не делать, делать нужно наоборот  -->
    <path fill="none" stroke-width="5" stroke="black" d="M28.5,2.023a28,28,0,1,1-28,28,28,28,0,0,1,28-28"/>
  </svg>
</svg>
<!-- Помещая svg в svg каждый имеет свой viewBox и родительский viewBox повлияет на дочерний. объект дочернего элемента может как уменьшиться
    Так и увеличиться. Позиция тоже играет роль. 
    Свойство style у дочернего блока перестаёт работать. По крайней мере стандартные свойства css как я заметил.
-->

<!--------------------------------------------------------------------------------------->
<!--#####----------<{ PATH }>----------#####-->

  <!-- path не имеет свойств управляющих его размерами например как реализовано в rect иметь размер viewport'a 
    близко далеко ли сделать холст через viewBox и задавать размер самому rect перемещая его большую или маленькую форму по
    viewPort. То же самое с circle,ellipse. line тоже можно перемещать, только уже нужно перемещать точки начала и конца, что становиться проблематично
    В случае с элементами завязанными на линиях что бы сделать отступ нужно по сути все точки передвинуть, а их тысячи может быть, 
    уж не говоря о том что в ручную постараться сделать отступ и уменьшить изображение к примеру для освобождения пространства под какой-то элемент, это все нитки придётся
    передёргивать пытаясь выдерживать пропорции. Так вообщем никто не делает. Для этого как раз проще отодвинуть viewBox и переместить по x y куда надо. 
    Поэтому не нужно делать ошибок помещая svg в svg и надеясь что элементы родителя мы уменьшим, а помещённый svg с его элементами будут окружать родительские элементы.
    Такой трюк прокатит только если у родителя не куча линий.     
     viewBox начальные координаты x - y это смещение холста. Например говорим дай координату 50го пикселя, Если картинка была на 20й координате, то она уедет в лево. 
     Так же и по y только всё происходит относительно левого верхнего угла и координаты по y вниз положительные, когда говорим дай
     50 по у изображение если было на 20px то уедет вверх так как запрашивали 50 с низу. 
     viewBox x y в % не рассматривает
  -->




  <!-- d контур фигуры в которой устанавливают пары точек x и y и пары маркируют буквами: 
    Разный регистр означает разный просчёт путей. Заглавные всегда "абсолютный путь относительно svg блока"
    Нижний регистр "путь относительный" работает относительно начальной точки. На саму начальную точку
    такая запись m 10 10 не влияет. Просто бывает на следующих парах чисел буквы не ставят и вот здесь m говорит что 
    координаты относительно ей пути будут работать.
    M || m - moveto (Начальная точка)
    L || l - lineto (последующие точки соединяющиеся друг с другом)
    иногда удобней по одной координате, 2я сама остаётся предыдущей. через L мы бы её повторяли
    H || h отвечает за "x" координату. координата по Y подразумевается предыдущая  
    V || v за "y". координата по X предыдущая
    Z || z - closepath без координат. (соединение предшествующей точки с точкой команды M) 
              Это лучше чем дорисовывать линию смыкаясь с начальной точкой. т.к. угол будет острый

Далее поинтересней. Кривые Безье. Имеются управляющие точки, их визуально не видно. Устанавливая их на самом деле строиться
    ломаные линии относительно начальной n кол-ва управляющих и конечной. Разные команды имеют своё кол-во управляющих.
    На ломаных линиях просчитывается формула по которой строиться плавня линия. 
  
    Q || q - ## quadratic Bézier curveto "Квадратичная кривая Безье".## (с одной точкой) как в canvas 
               x1, y1, x, y - Кривая строиться относительно начальной точки M или последней в списке, и 2й пары команды Q
               координаты с цифрой 1 устанавливают на холсте точку к которой и будет линия тянуться и искривляться

    T || t - ## shorthand/smooth quadratic Bézier curveto "Гладкая квадратичная кривая Безье". ##
              Координаты x y. Как это работает: T дополняет Q. T просто продолжает линию от 2й "x и y" пары команды Q.
              На этом отрезке появляется своя управляющая точка которая зеркально реагирует при управлении 1й пары "x1 и y1"
              команды Q. Так же есть 2й эффект
              Точки T установленные друг за другом при передвижении не сгибают линию в острый угол как делает L
              линия остаётся плавной полукруглой. Немного не понятно как добиваться нужного эффекта управляя ими.
              Эффект почему-то не всегда предсказуем. 

    C || c  кубическая кривая Безье. имеет 3 пары координат. x1,y1 x2,y2 - управляющие точки x,y - конечная
            Как это работает: При использовании связки Q и T видим как управляя одной парой зеркально меняет своё положение
            скрытая управляющая точка. Здесь же управляющие точки хоть и имеют связь, но они управляются в ручную. 
            Линия более детально можно настроить. Как это работает можно посмотреть тут https://codepen.io/anthonydugois/pen/mewdyZ

    S || s гладкая кубическая кривая Безье

    d="M 10 10 100 10" 2 пара цифр это уже не начальная точка и отвечает за L что отличать пишут нормально
    d="M10,10 L100,10" всё это можно писать с пробелами или без и использовать запятые или без них
    d="M10,10 L100,10 M30,30 L100,30 Z" цепь разрывается при на каждой новой M 
    d="M100,300 Q400 500 700 300"
    т.к. выяснили что иногда буквы могут быть не записаны то вот правило
если после команды L или l координат не последует буквы, то вторая пара координат рассматривается как L или l
если после команды H или h координат не последует буквы, то последующая координата рассматривается как H или h
если после команды V или v координат не последует буквы, то последующая координата рассматривается как V или v
если после команды Q или q координат не последует буквы, то последующие четыре координаты рассматривается как Q или q
если после команды T или t координат не последует буквы, то вторая пара координат рассматривается как T или t

-->







<!--#####----------<{ Вспомогательные элементы }>----------#####-->
1.
<!-- 
  Обычно такие элементы помещаются в тег <defs> - definitions — определения
  1. Обязательно имеют id по которому их используют основные элементы. Пример <circle fill="url(#myGradient)">
  2. gradientUnits относительно чего будут рисоваться градиент, блока или закреплён на объекте. по ум. objectBoundingBox на объекте (px или от 0-1 или 0%-100%)
  3. Если координаты не заданы, рисуется горизонтальный градиент слева направо.
-->
<linearGradient id="myGradient"  x1="100" y1="100"  x2="300" y2="300" >
  <stop offset="0%" stop-color="gold" /> <!--stop - управление цветом. отступ и цвет -->
  <stop offset=".50" stop-color="gold" /> <!-- можно задавать числом от 0 до 1 -->
  <stop offset="100%" stop-color="gray" stop-opacity="" /><!-- положение цвета, цвет, прозрачность-->
</linearGradient>
<!-- x1 y1 начальные x2 y2 конечные координаты. px, %,... -->
   

<radialGradient id="myGradient"cx="10" cy="10" gradientUnits="objectBoundingBox || userSpaceOnUse"> <!--координаты центра -->
  <stop offset="0%" stop-color="gold" /> <!-- отступ и цвет -->
  <stop offset="100%" stop-color="gray" stop-opacity="" /><!-- положение цвета, цвет, прозрачность-->
</radialGradient>
<!-- Общее важное свойство "gradientUnits"
  objectBoundingBox - по ум. градиент на объекте и координаты рассчитываются относительно этого объекта.
  userSpaceOnUse — градиент может не попадать на объект, т.к. координаты рассчитываются относительно блока SVG,
                   это значит что двигая объект градиент статичен и находиться на svg не смотря на то что задали fill элементу
   Оба свойства работают с % как обычно, но userSpaceOnUse работает ещё от 0 до 1, а objectBoundingBox может 
     указываться в px               
-->

<!--########------------<{ svg Фильтры }>---------###############-->
<!-- 
  svg имеют больше возможностей чем обычные css filter. 
  Разные фильтры с префиксом fe Записываются в блоке <filter id='myFilter'> </filter> после чего вызываются через свойство(атрибут в svg)
  filter="url(#myFilter)" 
 -->

<feOffset dx="60" dy="60" />  <!-- При накладывании filter можно делать отступы  -->

<feGaussianBlur in="SourceGraphic" stdDeviation="5" /><!--  как в css. При размытии видать границы блока filter.  -->
<!-- Срочно почитать. 2 Интересных эффекта расщепления -->
<feTurbulence baseFrequency="" numOctaves="" seed="" stitchTiles="" type=""/>
  <!-- 
    baseFrequency - обязательный параметр. Задаёт плотность(частоту) искажения. Задаётся от 0.001 до 1
    numOctaves
    seed
    stitchTiles
    type
   -->
<feDisplacementMap in2="turbulence" in="SourceGraphic" scale="50" xChannelSelector="R" yChannelSelector="G"/>
  <!-- 
    in2
    in
    xChannelSelector
    yChannelSelector
   -->
   <!-- ИЗУЧИТЬ -->
  <feColorMatrix values=" 1 0 0 0 0
                          0 1 0 0 0
                          0 0 1 0 0
                          0 0 0 20 -10" />




                    
<!--########------------<{ Разные svg доп элементы }>---------###############-->
<!-- 
  1. fill="url(#lg)" имеет выше приоритет чем fill="#fff". Если использовать плавную анимацию, то обратить внимание url стоит на use или на другом элементе
 -->
<!-- use - используется для вызова одного и того же элемента. Зачем копировать фигуру если можно вызвать 1 строчкой use. 
  свойства применяемые к каждому use не влияют на оригинальных исходник
-->
<use xlink:href="#id объекта" /><!-- Использует(вызываем непосредственно фигуры) копию части или группы существующего объекта на холсте.   -->
<!-- Пример -->
<rect id="r2" x="0"  y="0" width="45" height="45" />
<use xlink:href="#r2" clip-path="url(#myClip1)"  fill="red" />
<use xlink:href="#r2" fill="#blue" />


<!-- 
  При в use можно указать размер, но через css в use размер не задаётся

 -->

<!------------------------------------------------------------------------------------------>

<!-- pattern - это обёртка для элемента который нужно дублировать много раз на любом объекте пока его не заполнит. Применяется через  fill="url(#star)" -->
<pattern id="star" viewBox="0,0,10,10" width="20%" height="20%" patternUnits="userSpaceOnUse" patternContentUnits="userSpaceOnUse" 
         preserveAspectRatio="none" viewBox="0 0 100 100" >
  <circle cx="0" cy="0" r="10" stroke="black" fill="red"/>
</pattern>
<rect x='20' width='100px' height='100px' fill="url(#star)" stroke-width='2' stroke='black'/>

<!--   
  patternUnits="objectBoundingBox" - По ум. строим и двигаем блок mask (не смотря на то что двигать можем фигуру в mask) относительно элемента(ов) подключаемого pattern 
                                     userSpaceOnUse -  или относительно svg
  patternContentUnits="userSpaceOnUse" - строим и двигаем фигуры относительно svg, objectBoundingBox - или относительно элемента подключаемого pattern   
  width/height - использовать в %
  -->

<!------------------------------------------------------------------------------------------>

<!-- marker - это обёртка для элемента который нужно вставлять на промежуточных точках линии polyline, polygon. Вызывается на объекте
  marker-start/mid/end="url(#myMarker) 
-->
<marker markerUnits="userSpaceOnUse" id="myMarker"  refX="2" refY="2" fill="tomato" markerWidth="4" markerHeight="4" >
  <circle cx="2" cy="2" r="2"/>
</marker>
<polyline points="10 10, 10 130, 130 130, 130 230" marker-mid="url(#myMarker)" fill="none" stroke="#FF3F4F" stroke-width="8" />
            
<!-- 
*Фигура находящиеся в блоке marker строиться относительно его координатной сетки 
  markerWidth / Height - каких бы размеров фигура не была указана в marker, она будет ограничена размером самого блока marker 
  orient='40' - угол поворота для фигуры. transform="rotate()" тут не применимо
  refX / Y - фигура подключённая к линии в какую либо точку будет касаться своей нулевой координатой, фигуру(ы - одновременно) можно будет сдвинуть 
  markerUnits="strokeWidth" - по ум. размер фигуры, будет зависеть от размера линии подключаемого элемента. 
                              userSpaceOnUse - фигура не зависит от размера линии размер нужно настраивать
-->



<!------------------------------------------------------------------------------>
<!--#####----------<{ clipPath и mask }>----------#####-->
<!-- 
clipPath и mask нужно воспринимать как фигуру которую хотим вырезать. В случае с маск ещё установить уровень прозрачности на отдельных
её шаблонах(фигурах). Любые фигуры и картинки вне mask воспринимать как бумагу из которой нужно вырезать заголовку.
Осталось подогнать координаты. Если ошибиться координатами можно ничего не увидеть и подумать что ничего не сработало или как-то не так работает. 
Внимательно проверять относительно какого объекта вырезаем и нет ли смещения.

  1. В фигурах clipPath не работает куча всего. Основное перечислю fill, stroke, stroke-width, border, opacity  
  2. свойство clipPathUnits="objectBoundingBox" - относительно объекта работает на path и polygon и самое важное
     точки при этом значении работают в % и указываются от 0 до 1. Удобно получить нужную фигуру не думая о масштабе холста, но 
  3. Когда вырезание происходит относительно svg нужно правильно с позиционировать фон иначе не увидим нужного результата 
  4. Переданный текст в clipPath и применённый к изображению получим текст вырезанный из изображения
  5. clipPath можно напихать разных фигур даже с привязанной svg animation, получим анимированное вырезание.
  6. Вырезать на изображении относительно изображения clipPathUnits="objectBoundingBox", так как фигуры начинают работать в %
     а изображение скорей всего не квадрат, то и при попытке вырезать круг r='.5' точка на ширине 50% и высоте 50% получим овал.
  7. Группы в clipPath не работают, указывается без элемента <g>, <symbol>
  8. Вроде как с анимацией transform на FireFox есть проблемы
  9. clipPath не работает одновременно с mask
-->
  

<!-- 
  В чём прикол в использовании clipPath?
  Можно напороться на одну и ту же картину. Через clipPath можно так же рисовать любые фигуры, только действий больше
 -->

5.
<path d="M0 10 H100 V100" /><!-- Нарисовали фигуру -->
 <!-- или вырезали. Вырезали значит сохранили фигуру отрезав лишнее, а не дыру вырезали в виде фигуры -->
 <clipPath id="myCP" clipPathUnits="objectBoundingBox">
    <path d="M0 10 H100 V100" />
    <text x="0"  y="0" font-size="200px" ></text><!-- можно засунуть даже текст -->
 </clipPath>
<!-- А потом создать площадку (квадрат закрашенный например)из которой вырежем фигуру -->
<rect x="0" y="0" width="100%" height="100%" clip-path="url(#myCP)"/>
<!-- Всё конечно замечательно, но clipPath не для этого, а для вырезания фигур на 
  Изображении, а не на квадрате в виде рабочей площадки.
-->

6.
<mask id="myMask" stroke="gray" stroke-width="12" fill="white" maskContentUnits="userSpaceOnUse">
  <path d="M0 10 H100 V100" />
  <image xlink:href="img/image2.jpg" width="200" height="300" preserveAspectRatio="none" />
</mask>
<!-- 

  maskUnits="objectBoundingBox" - По ум. строим и двигаем блок mask (не смотря на то что двигать можем фигуру в mask) относительно элемента(ов) подключаемого mask 
                                     userSpaceOnUse -  или относительно svg
                                     От объекта всегда в % от 0 до 1
  maskContentUnits="userSpaceOnUse" - строим и двигаем фигуры относительно svg, objectBoundingBox - или относительно элемента подключаемого mask   

  1. Mask тот же clipPath но с включёнными аттрибутами fill, stroke, stroke-width, opacity для mask и его фигур.
  2. Цвета работают любые, но маска работает от белого оттенка к черному. Белый картинку видно черный картинку не видно, промежуточные полупрозрачный эффект 
  3. установив mask координаты maskContentUnits="objectBoundingBox", вырезание будет повторяться на каждом элементе подключённому к mask.
     При "userSpaceOnUse" фигура вырезания остаётся на svg для всех элементов.
  4. В mask можно засунуть image заготовку. Т.к. fill и прочие свойства не работают на картинке, её цвета и будут влиять как отобразиться картинка. 
  Отличие opacity режима от маски.
    opacity на одной из фигур в mask делает её прозрачной относительно других фигур в mask выше по структуре, так и относительно других элементов выше по структуре от используемого mask элемента.
    fill,stroke на одной из фигур mask 1. прозрачность уже можно контролировать для разных элементов фигуры, 2. прозрачность работает относительно элемента подключаемого mask опцию и выше по структуре. 
  
-->
 
  

<!------------------------------------------------------------------------------>
Расшифровка атрибутов
    cx, cy - установить center по x и y координатам
    x, y - блоки устанавливаются относительно начальной точки по координатам. координаты (x y) на svg блоке
           работают только если svg находиться внутри svg, внешний блок svg не будет реагировать на эти координаты
    r - радиус для круга 
    rx, ry - радиус для эллипса и квадрата. Если использовать любой из атрибутов только один, 
             то радиус для углов будет общий.А так закругляет стороны, но нельзя закруглять углы по отдельности. В таком случае рисовать что-то через path

    




<!-- ########---------<{ Подключение svg }>--------##########

  При подключении svg через img и background-image анимация в подключённых картинках svg, работать не будет 
  и воздействовать из css можно только на img блок, но не на svg.

  Подключение через object.
  Есть так же свои ограничения, но из вне до css можно достучаться если использовать в svg
      <?xml-stylesheet type="text/css" href="../../css/style.min.css"?> 
       
  Так же картинку нельзя подключить с другова домена
  css анимации так же работают + уже реагирует  на взаимодействие с пользователем (взаимодействие описано всё там же в svg) 
  и image так же будет картинки
  Между object указывается то что отработает если object по каким то причинам не отработает

  в svg вроде как можно использовать script что бы писать js внутри
 -->
 <object type="image/svg+xml" data="SvgImg.svg" width="200" height="200">
  <img src="SvgImg.png" width="200" height="200" alt="image format png" />
</object>
<!-- Так же примерно отработает как и object. Из вне не достучаться через js, -->
<iframe src="img/section4/groupRhombus.svg">
  <!-- <img src="SvgImg.png" width="200" height="200" alt="image format png" /> -->
</iframe>



<!-- вставлять просто svg в html имеет так же недостатки, не работает в таком случае кеширование в браузере, как я понимаю при следующем
  заходе на сайт загружается html и если мы указывали на сервере в cors что нужно кешировать сайт, то фото могут за кешироваться,
  а html не кешируется  
-->






<!-- 
  Ещё один способ подключения svg элементов по id через use. Называется таткой способ svg-спрайт.
  Создаётся 1 svg файл вместо кучи svg, например sprite.svg и переносятся туда svg элементы
  помещаются в тег symbol и не забываем передать viewBox.
  
  Используем в sprite тег symbol потому что надо передать viewBox картинкам, т.к.
  подключаем в свой новый svg который размером 300х150. 
-->
<svg xmlns="http://www.w3.org/2000/svg">
  <!-- Что либо привязанное к элементам за symbol, работать не будет -->
    <symbol id="twit" viewBox="0 -47 512.00203 512" >
       <path  d="m191.011719 419.042969c-22.140625 0-44.929688-1.792969-67.855469-5.386719-40.378906-6.335938-81.253906-27.457031-92.820312-33.78125l-30.335938-16.585938 32.84375-10.800781c35.902344-11.804687 57.742188-19.128906 84.777344-30.597656-27.070313-13.109375-47.933594-36.691406-57.976563-67.175781l-7.640625-23.195313 6.265625.957031c-5.941406-5.988281-10.632812-12.066406-14.269531-17.59375-12.933594-19.644531-19.78125-43.648437-18.324219-64.21875l1.4375-20.246093 12.121094 4.695312c-5.113281-9.65625-8.808594-19.96875-10.980469-30.777343-5.292968-26.359376-.863281-54.363282 12.476563-78.851563l10.558593-19.382813 14.121094 16.960938c44.660156 53.648438 101.226563 85.472656 168.363282 94.789062-2.742188-18.902343-.6875-37.144531 6.113281-53.496093 7.917969-19.039063 22.003906-35.183594 40.722656-46.691407 20.789063-12.777343 46-18.96875 70.988281-17.433593 26.511719 1.628906 50.582032 11.5625 69.699219 28.746093 9.335937-2.425781 16.214844-5.015624 25.511719-8.515624 5.59375-2.105469 11.9375-4.496094 19.875-7.230469l29.25-10.078125-19.074219 54.476562c1.257813-.105468 2.554687-.195312 3.910156-.253906l31.234375-1.414062-18.460937 25.230468c-1.058594 1.445313-1.328125 1.855469-1.703125 2.421875-1.488282 2.242188-3.339844 5.03125-28.679688 38.867188-6.34375 8.472656-9.511718 19.507812-8.921875 31.078125 2.246094 43.96875-3.148437 83.75-16.042969 118.234375-12.195312 32.625-31.09375 60.617187-56.164062 83.199219-31.023438 27.9375-70.582031 47.066406-117.582031 56.847656-23.054688 4.796875-47.8125 7.203125-73.4375 7.203125zm0 0" />
    </symbol>
  
    <symbol id="painting" viewBox="0 0 126.33 91.67" >
      <path class="a" d="M63.67,33.61c2.34.08,3.22,1,2.76,1.71-1.43,2.35-9.07,6.77-9.07,6.77L38.89,50.92S25,57,21.51,58.39s-11.33,3.29-11.33,3.29-13.79,4-8.45-7.15S18.15,32.11,18.15,32.11s8.9-8.93,17.7-14.37,12.86-6.23,12.86-6.23S57,9.33,61.37,14.38s7.91,13.84,7.91,13.84l2.32,7,2.33,10.19,3.46,15.48,6.48,30.66"/>
    </symbol>
  </svg>
  
  <!--
    Далее магия. use работать может не только внутри своего svg, но и за его пределами.
    Нужно указать путь спрайта и обратиться к id элемента
    В index.html
   -->
  <svg>
    <use xlink:href="./img/sprite.svg#twit"  />
  </svg>
  
  <!-- 
    Минусы:
    1. Всё что привязано к элементу в спрайте за пределами symbol это: css свойства, градиент и т.д
       не подтягиваются, (Если думаешь засунуть это всё в symbol то так не делают и это тож не прокатит) 
    2. Без танцев с бубном достучаться до тегов находящихся в symbol из css не выйдет.
    Плюсы:
    1. С сервера запрашиваем 1 файл svg а не кучу
    2. Из положительного свойства непосредственно в svg на элементах не слетают при подключении через use
   -->





</body>

</html>

