/*
  1. Для того что бы работать с TS требуется установить пакет: npm i typescript, он компилирует в js.
*/
/*##############-------------<{ Типы }>-------------##############
  Типы указываются после названия переменной с двоеточиями. Так же можно создавать свои типы которые 
  по нашему мнению лучше своим названием описывают. 
  Если присваивать неверный тип, выпадает ошибка. Можно указывать несколько вариантов типов.

  После компиляции ничего лишнего в JS не будет. 
*/

const isFetching: boolean = true;
const int: number = 41;//4.2 3e10 
const msg: string = 'строка';
const numberArray1: number[] = [1,2,3,4,5];//новая запись. string[] и т.д
const numberArray2: Array<number> = [1,2,3,4,5];//старая
const numberArray3: [string, number] = ['Вася', 23];//мешаный вариант
const variable: any = 'строка';//всё что угодно. Можно переназначать.

function method1(name: string): void { }//void означает то что функция не будет ничего возвращать
function method2(msg: string): never { //указываем never если метод точно выкинет ошибку. Или мы свою выкидываем или система сработает.(Например цикл будет бесконечный) 
  throw new Error(msg);
}

type ID = string | number;//Создали свой шаблонный тип

const id1: ID = '3123';
const id2: ID = 1234;

/*---------------------------------------------------------------------------------------------------------------------
##############-------------<{ Интерфейсы }>-------------##############
  Интерфейс похож на определение класса, но создаёт по сути шаблон для свойств с ограничениями по типам.
  ? - не обязательное указание данного свойства
  readonly свойство после заполнения нельзя будет переназначить
*/

interface React {
  readonly id: string,
  color?: string,
  size?: {
    width: number,
    height: number
  }
}
interface IReact2 extends React{ //Есть наследование. Часто вначале ставят I указывая что это интерфейс
  method2?: () => number //новая запись. С function как записывать не знаю.
}

const react1: React = {
  id: '1234',
  size: {
    width: 4,
    height: 6
  }
}
// react1.id = 465// нельзя переназначить

const react3 = {} as React; //привязать тип. Новая запись
const react4 = <React>{}; //старая


class MyClass implements IReact2{//привязываемся к нужному интерфейсу т.к. хотим заполнять теже свойства
  id: '151'
}


/*
  Представим ситуацию что объект длиннющий и хз сколько там свойств. Пришлось бы долго описывать интерфейс. 
  Для этого можно указать короткую запись.
*/
interface Style {
  [key: string]: string
}

const css: Style = {
  border: '1px solid red',
  marginTop: '10px'
}

/* 
  enum это просто названный список содержащий чего либо и названый элемент находиться на своей позиции индекса.
  На нормальный русский это типа массив записанный в другой форме. 
  let Membership = ['One', 'Two', 'Three'], но с одной фишкой
 */
enum Membership {
  One, 
  Two,
  Three,
}

const props1 = Membership[2];//Three. Результат как в обычном массиве
const props2 = Membership.One;//0 - обратившись по имени получаем индекс.В обычном массиве пришлось бы использовать findIndex()

enum SocialMedia {
  VK = 'VK', 
  FACEBOOK = 'FACEBOOK',
  INSTAGRAM = 'INSTAGRAM',
}
//если в enum свойствам присвоены значения, то при обращении через них будем получать не индекс а значения 
const props3 = SocialMedia.VK;//