/*------<{ Для сервера }>-------*/
"Nodemailer"(1 220 346) - отправка сообщений на ящик
"GraphQL" - это язык запросов для API. Надо почитать
"passport.js" - аутентификации в Node.js из сторонних сервисов (vk, google и т.д...)
"jsonwebtoken"(3 490 958) - получение токена
"npm-run-all"(1 183 640) - параллельного или последовательного запуска нескольких npm-скриптов (npm-p -записываеться),
                         concurrently(852 000) - тот же принцип
"node-sass"(3 181 973) - для работы с scss

   
"express" - фреймворк сервера, удобней чем встроеный пакет в NodeJS (http),
"express-handlebars" - шаблонизатор для того что бы не повторять html. На php многостраничный сайт раскидывают куски по файлам, на 
                       node нужен шаблонизатор
"dotenv"(8 269 112) - Загружает из файла .env (нами созданного в корне) переменные окружения в process.env
"config"(449 683) - принцип тот же как у dotenv, но чуть другой подход. Разница между собственым файлом config с передачей через
                    module.exports в том что не нужно ни где импортировать этот объект и обращаться через переменную

//для общего развития
"yargs" - (45 167 432) библиотека для получения данных из консоли. Если хочеться понять как gulp запускает отдельно таску, в то время как через nodejs
                     я могу запускать только целый файл, но не отдельно метод. Секрет кроеться в том что gulp так же запускает файл, но он смотрит process.argv
                     и т.к. не очень удобно там лазить, то библиотека как кстате

/*-----------------------------------------------------------------------------------------------*/
/*------<{ Для клиента }>-------*/
"formik", "react-form" - работа с формами. formik не нужно привязывать к redux state
"react-redux", "ModX" - работа с BLL функциональная и ООП разработка
"ClassNames" - библиотека для удобного управления классами. Ключ-класс, значение-bool 
"moment"(13 089 119), date-fns(7 301 377) - библиотеки для работы с датами
"prop-types" - проверка типов
"Yup" -  проверка типов + валидация. построент на Set Map для старых браузеров нужен полифил 'core-js/es6/set'
         так же при использовании TypeScript нужен npm install -D @types/yup
"Downshift"(502 947) - выпадающие списки
"Particles.js" летающая паутина
//для css
"@material-ui/core"(1 255 387), StyledComponents(1 881 181), Ant.Design(481 454) - готовые стили + настройка
"React Styleguidist" - библиотека упрощает создание логики компонентов таким образом что бы
                      можно было показать дизайнеру как компонент работает
"eslint" - Поствечивает ошибки в синтаксисе js и не только 
"Doiuse" - какой-то плагин который может подсказать глядя на код какие свойства не поддерживаються
         теми браузерами которые мы ему указали. Но нас выручает Autoprefixer

/*-----------------------------------------------------------------------------------------------*/
/*------<{ Общие }>---------------------*/

"axios"(10 981 160)(|| "request" - устарел) - HTTP запросы как с клиента так и с сервера
/*-----------------------------------------------------------------------------------------------*/
/*------<{ Помощь в разработке }>-------*/
    "gulp" - требуется для запуска различных задач которые нам помогают. удобство в том что команды запускаем через консоль 
    "gulp-sass" - тотже node-sass но работает с gulp
    "gulp-concat" - соединяет файлы
    "gulp-rename" - может переменовывать файл добавляя или изменять лишь часть имени
    "babelify" - тот же babel, но заточен работать с browserify 
    "vinyl-source-stream" - gulp работает на виниловом потоке и передавая через pipe данные из browserify работать не будут, только с этим пакетом
    "vinyl-buffer" - uglifyjs работает с этим виниловым буфером
   

    "browserify" - При проектировании разбиваем обычно код на модули js. Все модули по идее нужно включать один за другим в 
                 html в правильном порядке. При загрузке страниц будет куча запросов к серверу. Что бы этого не было все 
                 модули js объединяют в 1 или 2 файла. Чем и занимаеться данный сборщик. Вот ещё пару RequireJS(AMD), Webpack 
                 Сборка в CommonJS структуру это означает что файл синхронного исполнения. При любом запросе к серверу будет передан 1
                 собранный файл bundle.js. 
                 С AMD технически не нужен этап сборки, на котором объединяем все модули в один файл. Асинхронная загрузка модулей 
                 означает то, что мы постепенно загружаем модули по мере необходимости. Но большой объём запросов на каждое действие 
                 пользователя не подходит для продакшен
                 
                   
    "gulp-uglify" - ужимает, оптимизирует код приводя почти в не читаемый вид, но для машины нормально     
    "uglifyES" - es6 синтаксис воспирнимает        
    "gulp-sourcemaps" - при обращении к css или js через devTools браузера будем попадать не на сжатый файл, а на нормальный
    
    "gulp-autoprefixer" - добавляет префиксы css свойствам
    "browserSync" - обновляет браузер при каждом изменении в указаном файле
    "pump"(21 991 576) - что бы 100 раз не писать pipe в gulp тасках

фреймворки стилей Bootstrap (Twitter) vs Materialize (Google) vs Zurb Foundation 