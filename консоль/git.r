Есть ещё команда для графического показа коммитов.

gitk --all& 
git clone git|ssh|ult|src ["дирекотрия"]-не обяз, но при желании можно указать куда клонировать
git fetch git|ssh|ult|src - откуда забрать
git branch - проверить какие ветки есть
git push имя-репозитория имя-ветки//git push origin Redux

По комитам можно переходить использовав ID

#####---- git настройка ----######
git help название команды про которую ходим узнать

git init  появиться файл .gitignore начинаеться слежка за проектом. Нужно проследить что бы новый проект был инициализирован.
          У меня была проблема когда была инициализированна общая папка с проектами в итоге была путаница.
          Каждый проект своя инициализация. На это указывает скрытая папка в проекте .git
1м делом как только установили git нужно войти в свой кабинет через Git branch
git config --global user.email "you@example.com"
git config --global user.name "имя" вроде как это не то имя которое вводиться 1й раз перед подключением


git config --list  выводит настройки git
git config --global --list  имя email там можно проверить
git remote -v показывает все репозитории: имя репозитория(стандартно origin оставляют) и URL репозитория. 
git remote  //имена
git remote rm origin удалить можно лишний репозиторий из слежки
git status - проверить статус. 4 статуса Untracked, Unmodified, Modified, Staget

В новом проекте возможно будет старый репозиторий. Добавить новый. По сути привязываем локальный к глобальному репозиторию
git remote add <Любое название репозитория которое мелькает в объекте config> <сылка репозитория>



некоторые управляющие символы. работают на разных командах
-a   all
-m   master
-v   verbose
-t   branch
-f   fetch
-u --set-upstream
rm  remove  без -rm

#####---- git взаимодействие ----######
git clone URL проекта. //предварительно выбрав папку в которой вводим эту команду
git log --graph посмотреть кто на каких узлах (комитах)

git add название изменённого файла. "." выбирает все файлы. Указывается флаг -A без дальнейших названий если требуеться несколько файлов добавить
        git add подтверждает изменение файла, пересохраняя предыдущий файл. Если этого не сделать и ввести git commit то передастся
        предыдущий файл, а не новый. Кстате говоря когда мы пользуемся add мы добавляем изменение а локальный
        репозиторий который в дальнейшем переносим на github

git commit -m "какое-то указание к изменению"  если неправильно ввести то открываеться окно
git push -u <название репозитория сохранёного в remote> <название ветки которую хотим скинуть> //(master ветка главная обычно)
#####################################################################################
#-- Если возникнет какая-то непредвиденая хуйня
#-- ввести git push -f origin master что бы это не значило
#-- на каком то этапе использовании git push возможно будет просить что-то типо  git push --set-upstream origin master
#-- ведя её вроде всё начнёт работать
#####################################################################################
git push - дальше можно просто тыкать и отправляет в репозиторий
git push -f origin master  //после удаления папки .git и новой инициализации git выдаёт ошибки hint
                           (предлагает pull, но ошибка не уходит) -f решит проблему

git pull - если были изменения на репозитории кем-то, то эта команда скачает недостающие файлы, вместо того что бы по новой использовать git clone URL


Создание ветоки даёт возможность получить копию ветки master, в копии которой мы можем что-то делать и смотреть на результат прежде чем
делать слияние с веткой master. Все разработчики делают свои ветки и не мешают друг другу. Когда кто-то закончил, переносит копию
в мастер заменяя изменение файлов. Другие разработчики при обращении к ветке master получают сообщение что в ветке были некие 
изменения которые требуеться скачать 

#####---- git взаимодействие с ветками. На Одном репозитории. ----######
//есть основная ветка master
git branch <название ветки> - создаём ещё новую. Что бы перейти использовать checkout
git branch -D <название ветки> - удалить ветку

git checkout <название ветки для перехода>. Если указать -b то мы сразу создаём и переходим(branch можно не использовать)

git branch -a показывает все ветки как локальные так и с github (с github маркируються remotes/название/название ветки)
git branch -v -a показать доп информацию веток
git branch -d <название ветки> удаление ветки
git branch -m <новое название ветки> переменует текущую ветку

git branch --merge//посмотреть соединённые ветки

git merge <название ветки> - объеденяет ветки, но прежде чем объединить нужно перейти на главную ветку master. 
Чем то похоже на git pull, но pull забирает новые изменения с github


/*Решения разного рода ошибок*/

Вывод сообщения типа
warning: LF will be replaced by CRLF in package-lock.json.
The file will have its original line endings in your working directory

убираеться 
git config --global core.autocrlf false
git config --global core.safecrlf false