*{
	box-sizing: border-box;/*размер блоков внутри блока при 100% размере будут растягиваться до бордера родителя 
													 а не размером с родителя из-за которого правая граница и низ выходят за пределы потому  */
	box-sizing: content-box;
}

.container {/*container как правило задаёт только ширину. Высота зависит уже от контента*/
	max-width: 1170px;/*ширина сетки*/
	margin: 0 auto;/*выравнивает блок по центру при условии что он не растянут на весь родительский блок, а имеет свою ширину.
									Не работает на inline и inline-block. svg inline-block, но не работает.
									Кстате если использовать отступ в % то высчитывается из ширины родительского блока. Обычно она 100% ширины браузера.
									margin = parentWidth / 100 * childMargin n %. 
									Пример: 1920 / 100 * 20% = 384px ну или сократить 1920 * 0.20
	*/
	text-align: center;/*задав такое свойство в блоке, находящиеся в нём инлайновые элементы сдвинуться в центр.
											img элемент в том числе */
	padding: 0 15px;/*за ранее выставлен отступ что бы не моб. технике не прилипало к краям. 
										Иногда встаёт выбор padding или margin. padding когда блок видимый и имеет 
										фон, убрать залипание самое-то или если нужно по площади увеличить
										взаимодействие с блоком, Обычно ссылки или кнопки и чаще они видимы хотя бы 
										при hover. Margin если блок ни как не выделяться и нет взаимодействия. 
										Можно представить ситуацию как будет выглядеть тот блок если на нём поменяют фон
										Объекты будут видны прилипшими? если да то padding лучше. Так же сузить размер браузера элементы прилипли? */
}
/*
	В вёрстке встретятся блоки которые не должны быть на всю ширину, но и в контейнер вносить для этого блока мы не можем
	для этого потребуется после контейнера делать wrap 
*/

/*#######---------<{ Как не использовать .container }>--------########*/
/*
	Главному блоку задавать динамический padding
	 1180px, значит 1920 — 1180 = 740 / 2 = 370px — будут боковые отступы в нашей секции
	 590px и сделать контент 1140px или 1170px, как угодно!

	 некоторые формулы на размышление
	 (100% - 1180px)/2 = 50% - 590px, где (100% - 1180px) — это сумма боковых полей.
*/
section {
	padding: 0 calc(50% - 590px);
	padding: 0 calc(50vw - 590px);/*Надёжней.Чтобы ширина считалась не от родителя, а от ширины области промотора браузера.*/
}
/*
Минусы padding:
	Нужно для секций задавать padding-top и padding-bottom отдельными свойствами.

То есть не:
section {
  padding: 50px 0;
}

А вот так:
section {
  padding-top: 50px;
  padding-bottom: 50px;
}

Иначе они перезапишут динамические отступы. Но это намного лучше чем классический .container
Вариант media запросов
*/

section, header, footer {
  padding: 0 15px;
}

@media (min-width: 575.98px){
  section, header, footer {
    padding: 0 calc(50vw - 270px);
  }
}

@media (min-width: 767.98px){
  section, header, footer {
    padding: 0 calc(50vw - 360px);
  }
}

@media (min-width: 991.98px) {
  section, header, footer {
    padding: 0 calc(50vw - 480px);
  }
}

@media (min-width: 1199.98px){
  section, header, footer {
    padding: 0 calc(50vw - 590px);
  }
}


/*#######---------<{ Просто описание свойств }>--------########*/
body {
	/*Хорошая практика если пробежаться по макету и определить среднее значения свойств которые можно указать
		в body и в дальнейшем в некоторых классах можно будет опустить запись переназначения дефолтных значений. 
		Так же в отдельных блоках если в дочерних элементах повторяются свойства можно задать родителю.

		Так же не мало важно определить одинаковые стили для каких-то элементов для которых можно создать один класс и 
		описывать его.
	*/
	background: linear-gradient(#121619 0%, #1a1f24 50%, #121619 100%);/*в css градиент изначально в горизонтальном положении, в то время как в фотошопе 90градусов это горизонталь */
	font-size: 16px;
	font-weight: bold;
	line-height: 1.8;/*расстояние между строками. Использовать лучше в относительной единице. Если увеличить font-size то и расстояние между строк увеличиться нормально, а не будет статичен  */
	letter-spacing: 0.25px;/*расстояние между буквами*/
	border-width: 2px 5px 2px 2px;/*ручной контроль по кругу*/
	outline: 2px 5px 2px 2px;/*это по сути бордер над бордером*/
	position: relative;/*Не покидает родителя. В родителе может не быть размера, и установленный размер контента растянет родителя не смотря на relative */
	position: absolute;/* при absolute элементы становятся как бы  block .*/
	/*
		1. Если у родителя нет размеров, он зависит от размера дочерних элементов, то при использовании position: absolute или float 
				на дочерних элементах,родительский элемент потеряет размер т.к. элементы выпрыгивают наружу и находятся сами по себе
				со своим размером, но они могут позаимствовать родительский размер, но опять же только для себя.
		2. position: absolute ищет ближайший родительский блок со свойством position. В идеале должен встретить relative,
			 но если родитель так же absolute то привязывается к нему. Если у дочернего элемента
			 стоит размеры указанные в % то которые работают относительно родителя, то т.к. у родителя не указан размер (п.1)
			 то и в дочернем элементе % не от куда будет взяться.
		
	ИТОГ: везде где absolute и float мы не можем родителем опираться на размер дочерненго элемента. Родитель должен иметь свой габарит.
	Лучше всего минимизировать эти свойства что не переписывать кучу размеров под адаптив
	
  Предположим
   relative выше на более 1 блока от дочернего элемента с absolute. Задаю размеры там. Там где relative предполагаю 
   установить для дочернего эл. размер. Да я могу в дочернем элементе где-то там внизу далеко по уровню ссылаться на 
   родительский размер через %, но из-за того что но блоки стоящие перед блоком со свойством absolute будут свёрнуты,
   везде придётся делать или свой размер или ставить зависимость для каждого блока в %, что бы передать всем размер от родителя 
	 в px. И ещё т.к. блок с absolute старается привязаться к блоку со свойствам position и как было сказано он выпадает,
	 и если то в промежуточных блоках нет это свойства то установив в них бордеры видно что блоки находятся друг в друге и так как
	 блок с absolute не сними они отодвигают его от блока с relative.
	 В таком случае прописать всем absolute и блоки лягут друг в друга до родителя
	 

   ИТОГ: Я думаю нет необходимости привязывать блок absolute к блоку relative через несколько родительских блоков. 
         Как я и говорил что бы меньше писать адаптива проставляя кучу размеров нужно плясать от размера контента

	*/
	width: 100%; height: 100%;/*1й способ растянуть с absolute. Кстате при вёрстке стараются размеры задавать последнему элементу в цепи */
	top: 0; left: 0; right: 0; bottom: 0; margin: 0 auto;/*2й способ*/
	flex: 0 0 100%; /* Сокращённая запись: flex-grow, flex-shrink, flex-basis;*/
	width: 100%;/*Вроде как удобней задавать родителю в % что бы блок был резиновый. В px указывается непосредственно контенту 
							 Родителю указываются в px это min max размеры высоты и ширины что бы иметь хоть какие то рамки
							 Не мало важно что блок установленный на 100% ищет верх по структуре до ближайшего px размера 
							 */
	padding: 10px;/*display:flex выравнивание хорошо, но не даёт отступы. Не забываем ставить */
	margin: 0 auto;/*Не работает на inline и inline-block*/
	justify-content: center;/*Не заменяет свойство text-align т.к. свойство выравнивает контент с текстом, но текст
													 по прежнему прибит к левому краю. text-align: center решает эту задачу */
	float: left;
	/*Как работает float
		Не забываем что после установки свойства элемент выскакивает со всеми своими вложенностями на поверхность. 
		Если родитель держался только на этом блоке и так же родитель для какого-то элемента уже relative, то контент с 
		position: absolute тоже будет свёрнут т.к. он давно с наружи и держался.
	При использовании слайдера float лучше не использовать. Поведение не понятно.

	 У float поведение чем-то похоже на absolute, но со своими особенностями
	 Следующий после его блок займёт его место, контент в том блоке будет обтекать этот блок будто они на одном уровне.
	 Перемещать блок можно в лева и в права. С лева - обтекает с права, с права - обтекает с лева.    
	 
	 Оказывается float не работает с 1ми дочерними элементами от родителя flex 
	*/
	clear: right;/*Убирает обтекание*/

}


:root {
	outline: none;/*стандартное выделение. Рамка выше border*/
	box-shadow: 0 0 10px 20px black;	/*оказывается есть необязательный параметр толщины 20px */
	overflow: scroll;

	/*Для таблиц*/
	display: inline-table; 
  display: table-cell; /*присваивает тип ячейки таблицы*/
}
.parent .child{

	flex-basis: 50%;/*По ум. auto. Управляет размером блока. Сколько % должен занять блок в родительском блоке*/
	flex-grow: 1; /*По ум. 0. Растянется на всю оставшуюся ширину*/
	flex-shrink: 0;/* По ум. 1. Отвечает за автоматическое сжатие блока.. Можно min-width: max-content; или выключить сжатие flex-shrink: 0 */
}
button{
	font-size: 0;/**/
	width: 10px;
	height: 10px;
	border-radius: 50%;
}
/*
Селекторы_отношений
X > Y (родитель > дети) предназначен для выбора элементов, определяемым селектором Y непосредственно 
       расположенных в элементе, определяемым селектором X.

input + label выберет все элементы label, которые расположены сразу же за элементом input, 
         и являющиеся друг по отношению к другу соседями (сиблингами).
p ~ span выберет все элементы span, расположенные после элемента p на том же 
         уровне вложенности.

Вроде input не содержит ::after и ::before поэтому заворачивают в div
*/
.myClass:target {
	/*Отработает если была нажата где-то ссылка в атрибуте которой передан именно id
	блока у которого ещё и класс myClass. 
		<a href="#myId"></a>
		<div id="myId" class="myClass"></div>
		Что-то типа label для input
	*/

}
/*Вроде нужная штука при разработке модальных окон.  На заметку если неправильно привязать модальное окно,
	1. При закрытии окна если мы будем находиться внизу, окажемся снова на верху сайта. Привязывать нужно 
			к элементу который ходит за нами. (Header например) или зафиксировать пиксель 
	2. Что бы страница не перезагружалась в close ставят href="#" но при клике она будет в url
При таком подходе на css скролится задний контент и url заполняется не нужным хламом. Лучше делать на js.
Так же не забываем что организовать крестик можно через checkbox
*/
  

.myClass:not(:first-child) {
	/*скрыть всех кроме 1 элемента*/
	display: none;/*Переход none в какое либо состояние не анимируется свойством transition*/
	display: flow-root;
	
	position: sticky;
	overflow: hidden;
	transform: perspective();/*оказывается есть метод. Свойство transform работает только с блочными элементами*/
	transform: scaleX(-1);/*scale отвечает за масштабирование. Если задать отрицательное значение стороне будет уменьшение и снова увеличение, но в отрицательную сторону
														получается разворот, будто бы использовали rotateY(180deg) именно по оси Y */
	
	transform: skewX();/*делает скосы, блок становиться параллелограммом по нужным осям */
	/*Так же в свойство не будет работать если общему классу задать общее значение transform, а потом
		дочернему что-то езё дополнять указав снова это свойство
	*/
	transform: matrix(scaleX, skewY, skewX, scaleY, translateX, translateY);
	/*
	Свойство matrix заменяет несколько свойств трансформации. Единица не указывается, но должны знать в чём
	в каких единицах работают другие свойства что бы понять какие цифры писать.

	matrix (a, c, b, d, tx, ty)
  масштабирование. Число это множитель на размер блока
  	a - в ширину. 1 - это нормальный размер, всё что меньше уменьшение, больше увеличение 
  наклоны параллелограмм. Число хрен знает как вычисляется, но это не deg. Использование skew с единицей deg даёт другие результаты при тех же цифрах 
  	с -  Положительное значение наклоняет вверх, отрицательное вниз.
		b -  Положительное значение наклоняет влево, отрицательное вправо.
	масштабирование
		d - в высоту. 1 - это нормальный размер, всё что меньше уменьшение, больше увеличение 
  Смещение в пикселах. Единицу так же указывать не надо
  	tx - Положительное значение сдвигает элемент вправо, отрицательное влево.
		ty - Положительное значение сдвигает элемент вниз, отрицательное вверх.
	Существуют формулы. Если интересно можно почитать
	*/
	
}
select{
	padding: 0 10px;
	/*
		Обычно у input делают отступы слева и справа. У select отступ с лева делается, а с права нет, стрелка справа 
		останется на своём месте. Иногда требуется стилизовать стрелку, да и вообще input.
		Можно стилизовать чрез тег label привязав input после его скрыть или убрать вовсе 
	*/
	
}




/*При построение списков видел такой приём. Структура как обычно <li><a></a></li> Предположим ссылки имеют border. li находятся
  плотно друг к другу и стили им не присваивали. Ссылки тоже будут плотно прижаты. Я бы делал разрыв примерно так*/
nav .li{ margin-right: 10px; }
nav .li:last-child{ margin-right: 0px; }
/*Вот видел такой прикол*/
nav .li + .li{ padding-left: 10px; }
/* 1. Блоки li остаются плотно т.к. отступ внутренний, но из-за того что нет стилей видимо и так сойдёт
	 2. Действительно как я раньше не допёр исключать таким образом 1й элемент от ненужного указания свойств
			Заменяет такую запись 
			nav li:nth-child(1n + 2){ padding-left: 10px; }
			(an + b), где a и b целые числа, n — счетчик, который автоматически принимает значение 0, 1, 2.
*/
/*
	При такой структуре <li><a></a></li> если <a> задать внутренний отступ то границы будут вылазить за пределы <li>
	ВАЖНО нужно всегда указывать ссылкам display: inline-block или block.
	Как по мне лучше забыть использовать стиль обычного display: inline; Слишком много гемороя вылазит из этого свойства
*/


/*При наведении за ранее зарезервировать border*/
nav .li a{ border: 1px solid transparent; }
nav .li a:hover{ border: 1px solid rebeccapurple; }





textarea {
	resize: none;
	/*убирает возможность изменять размер*/
	padding: 10px;
	/* не забывать делать отступы у */
	position: absolute;
	/*поднимает блок по z координате на 1 шаг. по ум привязывается к окну браузера */
	/*
		Если элементу выше было задано left: 0, то вроде при попытке задать right значение оно неохотно будет 
		применяться, для этого задать left: auto;
	*/
	left: auto;
	right: 20px;
}

/*####----<{ Заметки }>-----####*/
/* 
	Встретил баг в flex. Если один блок фиксированный, 2й блок нет и наполнен контентом под завязку,
	то 1й блок хоть и фиксированный он ужимается. Вариант или задать обычным способом размер нефиксированному блоку 
	или растянуть через flex-basis: 60%; так что бы не сжал фиксированный блок или выключить сжатие которое по ум. включено.
	flex-shrink: 0.

	Ещё с flex выяснилась такая штука. По умолчанию дочерние элементы принимают форму самого высокого блока. Что бы
	убрать это состояние нужному дочернему присваивается align-self: baseline; или start
	

	При использовании position: absolute не забываем что элемент находиться на поверхности и 
	если предусмотрен контент на блоке над которым с позиционирован этот элемент, то нужно накидать 
	контента и проверить не будет ли контент залазить под этот элемент и сделать нужные padding отступы 
	контенту 
	 	
	Если задаётся float дочернему элементу, то родителю можно задать clear: both и вроде как блок не будет вылезать за родителя   

	3 колонки имеют разное наполнение текста имеют так же кнопки. Что бы кнопки не были на разных уровнях один из вариантов,
	задать колонкам relative, сделать отступ с запасом, кнопкам задать absolute и выставить bottom на нужную высоту

	Если в свойстве position использовать 2 свойства left 0 и right 0 то блок встаёт по середине. По вертикали тоже самое.
	Таким образом элементы находящиеся в этом блоке встанут по середине и между ними можно сделать отступ тогда они будут отталкиваться 
	друг от друга.

	При подключении других библиотек возможно понадобиться изменить поведение. Как вариант смотреть классы в действии и переопределять
	
	Подключение локальных шрифтов + Препроцессор SCSS.
		При подключении шлифтов имеем файл scss где прописаны шрифты и их путь, так вот путь нужно учитывать не относительно
		_fonts.scss а относительно файла style.css потому что к шрифтам он обращается а не scss 
	
*/

/*########------<{ Практические казусы }>----------------------------------------------------------*/
/*БОЛЬШАЯ ОШИБКА делать так. Предположим у 2х элементов общий класс и отдельные свои классы.
<span class="slider__btn slider__btn--left"></span>
<span class="slider__btn slider__btn--right"></span>
Как НЕ СТОИТ делать
*/
.slider__btn::after,
.slider__btn::before{
  content: '';
  width: 10px;
	height: 10px;
	content: '';
  width: 10px;
  height: 10px;
  display: flex;
  justify-content: center;
  align-items: center;
}
.slider__btn--left::before {
	/*Ожидать что тут будет по середине. Квадрат будет смещён потому что рядом 2й квадрат от after тоже в 
		середине стоит скрытый */
  border: 1px solid #000;
 
}
/*Правильный вариант. Но за ранее скажу что делать стрелки из бордера потом переворачивать на 45 и 135 градусов, и пытаться выровнять
	через flex. Они не окажутся по середине, верней ось квадрата по середине как полагается когда мы разворачиваем получаем ромб и оставляем одну 
	из частей она остаётся на своей стороне часть ромба и нам надо что бы она уехала на середину со своей стороны.
	Вот как довольно точно выровнять. И делать нужно именно в таком раскладе. не правильная установка translate будет не так высчитывать
*/
.slider__btn {
  width: 50px;
  height: 60px;
 
  margin-left: 20px;
  border: 2px solid darkorchid;
  display: block;
  position: relative;
 
}
.slider__btn::before{
  content: '';
  --border: 3px;
  width: var(--sliderArrowSize);
  height: var(--sliderArrowSize);
  border-top: var(--border) solid #000;
  border-left: var(--border) solid #000;
  
  position: absolute;
  top: 50%;
  left: 50%; 
 
}
/*сдвиг на 4ю часть квадрата*/
.slider__btn--left::before {
  transform: translate(-25%, -50%) rotate(-45deg);
}
.slider__btn--right::before {
  transform: translate(-75%, -50%) rotate(-225deg);
}

/*#########----<{ Необычные свойства }>----#########*/
.el{
	background: url('../img/image1.jpg') 250px /cover no-repeat,
	url('../img/image2.jpg') center /cover no-repeat;

	background-blend-mode: lighten; /*Определяет режим наложения. свойство работает в одном блоке. под одним background должно указано 2 картинки или картинка и цвет */
}

.el{
  width: 500px;
  height: 300px;
  background: wheat;
}
.el__child{
	background: url('../img/image1.jpg') center /contain;
	/* contain растянет на весь блок ориентируется по ширине изображение, cover по высоте */
  width: 100%;
  height: 100%;
  mix-blend-mode: luminosity;/*Определяет режим наложения. Работает уже относительно родительского background или цвета или image */
	/* в обоих случаях изображение или цвет можно менять местами */
}

.parent{
	-webkit-text-stroke: 4px red; /* толщина и цвет обводки текста. Через svg и stroke-width можно добиться того же результата */
	/* Обычно толщина обводки подгоняется через text-shadow: и километровый код*/
}

