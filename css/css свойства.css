/*
	1. В css есть лимит селекторов в 1 файле. 4095 селекторов, остальное будет вырезаться
	2. padding указанный по вертикали в % рассчитывается относительно ширины контейнера.
			Ширина / указанный % = padding;    Ширина / желаемый отступ = число в % для padding

		 padding-top: 10%; при блоке на всю ширину это  1920-(скролл)=1889/100*10%=189.9px отступ вниз
		 Пример: 
		 		У родителя нет отступов и его ширина 1000px.   
						ширина родителя / желаемую высоту * 100% =  
		 


	На выработку привычки.
	 варианты событий:  Что продуктивней?
  1. добавлять везде класс с opacity и translate и убирать класс в нужный момент
	2. везде добавлять opacity и translate и применять класс который переопределяет эти свойства 
	3. Не нужно применять padding-hack для пропорционального изменения высоты блока, нужно просто
		 использовать для блока @media когда требуется менять высоту и задать высоте единицу "vw".
	4. Создавая в начале вёрстки общий элемент для разных секция, не нужно ограничивать его ширину даже 
		 если везде одинаково. Пример внизу  "Заметки"

*/

* {
	/*Без box-sizing ширина блока будет складываться с padding и border и в итоге блок будет больше нужного*/
	box-sizing: border-box;
	/* размер блока всегда будет например 300px насколько бы широкий border или отступ не поставили. Толщина border 
													  в таком случае будет съедать внутреннюю часть блока.    */
	box-sizing: content-box;
}

.container {
	/*container как правило задаёт только ширину. Высота зависит уже от контента*/
	max-width: 1170px;
	margin: 0 auto;
	/*выравнивает блок по центру при условии что он не растянут на весь родительский блок, а имеет свою ширину.
									Не работает на inline и inline-block. svg inline-block, но не работает.
									Кстате если использовать отступ в % то высчитывается из ширины родительского блока. Обычно она 100% ширины браузера.
									margin = parentWidth / 100 * childMargin n %. 
									Пример: 1920 / 100 * 20% = 384px ну или сократить 1920 * 0.20
	*/
	text-align: center;
	/*задав такое свойство в блоке, находящиеся в нём инлайновые элементы сдвинуться в центр.
											img элемент в том числе */
	padding: 0 15px;
	/*за ранее выставлен отступ что бы не моб. технике не прилипало к краям. 
										Иногда встаёт выбор padding или margin. padding когда блок видимый и имеет 
										фон, убрать залипание самое-то или если нужно по площади увеличить
										взаимодействие с блоком, Обычно ссылки или кнопки и чаще они видимы хотя бы 
										при hover. Margin если блок ни как не выделяться и нет взаимодействия. 
										Можно представить ситуацию как будет выглядеть тот блок если на нём поменяют фон
										Объекты будут видны прилипшими? если да то padding лучше. Так же сузить размер браузера элементы прилипли? */
}

/*
	В вёрстке встретятся блоки которые не должны быть на всю ширину, но и в контейнер вносить для этого блока мы не можем
	для этого потребуется после контейнера делать wrap 
*/

/*#######---------<{ Как не использовать .container }>--------########*/
/*
	Главному блоку задавать динамический padding
	 1180px, значит 1920 — 1180 = 740 / 2 = 370px — будут боковые отступы в нашей секции
	 590px и сделать контент 1140px или 1170px, как угодно!

	 некоторые формулы на размышление
	 (100% - 1180px)/2 = 50% - 590px, где (100% - 1180px) — это сумма боковых полей.
*/
section {
	padding: 0 calc(50% - 590px);
	padding: 0 calc(50vw - 590px);
	/*Надёжней.Чтобы ширина считалась не от родителя, а от ширины области промотора браузера.*/
}

/*
Минусы padding:
	Нужно для секций задавать padding-top и padding-bottom отдельными свойствами.

То есть не:
section {
  padding: 50px 0;
}

А вот так:
section {
  padding-top: 50px;
  padding-bottom: 50px;
}

Иначе они перезапишут динамические отступы. Но это намного лучше чем классический .container
Вариант media запросов
*/

section,
header,
footer {
	padding: 0 15px;
}

@media (min-width: 575.98px) {

	section,
	header,
	footer {
		padding: 0 calc(50vw - 270px);
	}
}

@media (min-width: 767.98px) {

	section,
	header,
	footer {
		padding: 0 calc(50vw - 360px);
	}
}

@media (min-width: 991.98px) {

	section,
	header,
	footer {
		padding: 0 calc(50vw - 480px);
	}
}

@media (min-width: 1199.98px) {

	section,
	header,
	footer {
		padding: 0 calc(50vw - 590px);
	}
}


/*#######---------<{ Просто описание свойств }>--------########*/
body {
	/*Хорошая практика если пробежаться по макету и определить среднее значения свойств которые можно указать
		в body и в дальнейшем в некоторых классах можно будет опустить запись переназначения дефолтных значений. 
		Так же в отдельных блоках если в дочерних элементах повторяются свойства можно задать родителю.

		Так же не мало важно определить одинаковые стили для каких-то элементов для которых можно создать один класс и 
		описывать его.
	*/
	background: linear-gradient(#121619 0%, #1a1f24 50%, #121619 100%);
	/*в css градиент изначально в горизонтальном положении, в то время как в фотошопе 90градусов это горизонталь */
	/*#######--------<{ Свойства для текста }>--------#########*/
	font-size: 16px;
	font-weight: bold;
	font: 12px bold italic 'Fira Sans', sans-serif;/*сокращённая запись*/
	font-stretch: expanded;/*свойство делает шире буквы*/
	text-indent: 10px;/*отступ в начале текста. этот отступ до ::before как и padding, margin */
	
	text-align: justify;	/*Выровнять текст по ширине блока.Так же есть left, right, center  */
	text-align: center;
	/*свойство в блоке текста выравнивать только текст. Если использовать в родителе, то
												свойство выравнивает инлайновые блоки и выравнивает текст в них(к тексту можно применить block всё равно выровняет)*/
	line-height: 1.8;
	/*расстояние между строками. Использовать лучше в относительной единице. Если увеличить font-size то и расстояние между строк увеличиться нормально, а не будет статичен  */
	letter-spacing: 0.25px;	/*расстояние между буквами*/
	user-select: none;	/*Нельзя выделить текст*/
	text-transform: uppercase;	/*высота текста*/
	text-decoration: underline;	/*подчёркнутый, зачёркнутый - декорация над текстом*/
	text-underline-position: auto; /*управляет положением линии под текстом. на label чёт не прокатило*/
	text-emphasis: "@" red;/*Помещает в тексте над каждой буквой символ*/
	writing-mode: horizontal-tb;/*по ум.horizontal-tb. текст можно написать вертикально vertical-lr*/
	/*--------------------------------------------------------------------------------------------------------------------------------*/
	vertical-align: bottom;/*Есть баг в котором при установке inline элементов могут находиться не на одной линии со смещением в пару 
													 пикселей. Это свойство выравнивает элементы относительно друг друга, даже если они не одинаковой высоты */
	border-width: 2px 5px 2px 2px;/*ручной контроль размера по кругу*/
	outline: 2px 5px 2px 2px;	/*это по сути border над бордером*/
	border-radius: 20px 0 30px 0;/*тож можно по кругу задать радиус*/
	

	display: inline-block;
	background-color: darksalmon;
	border-radius: 20px;
	
	padding: 10px;
	box-decoration-break: clone;
	/*даёт возможность оформить каждую строку так же как предыдущую
																без оборачивания каждой строки в span*/


/*#######---------<{ свойство position: relative, (fixed,absolute), sticky }>--------########*/
	/* 
		свойство position: absolute,fixed Одна из особенностей это перемещать элементы так что бы они при перемещении не мешали(не перемещал)
		другим элементам и не ломали вёрстку.
		Хотя перемещать элемент можно через transform: translate. Другие элементы так же не будут перемещаться
	*/
	position: fixed;	/* свойство фиксирует элементы к окну браузера. Так делают меню и модальные окна. Нужен top иначе можем не увидеть объект*/
	position: absolute;/*  */
	position: relative;	/* 1. Не выпрыгивает из блока как absolute. 2. Привязывает к себе absolute. 3. Размер контента свободно растягивает этот блок.  */


 /*
    1. relative - не влияет на блок. Если он блочный он будет растягиваться, строчный будет растянут по контенту
    2. absolute, fixed - принудительно становиться строчным и можно регулировать размеры left:0 right:0 
                          или width: 100%. display block и margin: 0 auto не будут работать
                          display:flex; сжимает контент
    3. Использовав в родителе flex, родитель подстроиться по высоте под контент. Если нужно 
        ограничить контент и сделать прокрутку, то или родителю
    4. Если в родителе использовать absolute,fixed + flex и в цепи дочерних элементов встретится 
        ещё раз absolute, то контейнер схлапывается. дочернему нужно указать flex-basis: 100%;             
*/ 
	/*
		1. Если у родителя нет размеров, он зависит от размера дочерних элементов, то при использовании position: absolute или float 
				на дочерних элементах,родительский элемент потеряет размер т.к. элементы выпрыгивают наружу и находятся сами по себе
				со своим размером, но они могут позаимствовать родительский размер, но опять же только для себя.
		2. position: absolute ищет ближайший родительский блок со свойством position. В идеале должен встретить relative,
			 но если родитель так же absolute то привязывается к нему. Если у дочернего элемента
			 стоит размеры указанные в % то которые работают относительно родителя, то т.к. у родителя не указан размер (п.1)
			 то и в дочернем элементе % не от куда будет взяться.
		
	ИТОГ: везде где absolute и float мы не можем родителем опираться на размер дочерненго элемента. Родитель должен иметь свой габарит.
	Лучше всего минимизировать эти свойства что не переписывать кучу размеров под адаптив
	
  Предположим
   relative выше на более 1 блока от дочернего элемента с absolute. Задаю размеры там. Там где relative предполагаю 
   установить для дочернего эл. размер. Да я могу в дочернем элементе где-то там внизу далеко по уровню ссылаться на 
   родительский размер через %, но из-за того что но блоки стоящие перед блоком со свойством absolute будут свёрнуты,
   везде придётся делать или свой размер или ставить зависимость для каждого блока в %, что бы передать всем размер от родителя 
	 в px. И ещё т.к. блок с absolute старается привязаться к блоку со свойствам position и как было сказано он выпадает,
	 и если то в промежуточных блоках нет это свойства то установив в них бордеры видно что блоки находятся друг в друге и так как
	 блок с absolute не сними они отодвигают его от блока с relative.
	 В таком случае прописать всем absolute и блоки лягут друг в друга до родителя
	 

   ИТОГ: Я думаю нет необходимости привязывать блок absolute к блоку relative через несколько родительских блоков. 
         Как я и говорил что бы меньше писать адаптива проставляя кучу размеров нужно плясать от размера контента

	*/
 

	/*------<{ Примеры }>-------->>>>>>>>>>>>>*/
	/* Обычное выравнивание по вертикали position: relative; не всегда подходит если на пути элемент вверху будет ещё элемент,
			то выравнивание будет не по центру*/
	/*.text{ */
	border: 1px solid #000;
	position: relative;
	/*следует ставить absolute*/
	top: 50%;
	transform: translateY(-50%) rotate(45deg);
	/* имеет значение последовательность методов трансформ */
	/*}*/


		/*ПРОВЕРИТЬ. КАЖЕТСЯ НА SVG НЕ РАБОТАЕТ align-self в режиме горизонтального выравнивания */

	position: sticky;

	display: flex;
	align-items: flex-end;

	width: 100%;
	height: 100%;
	/*1й способ растянуть с absolute. Кстате при вёрстке стараются размеры задавать последнему элементу в цепи */
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	margin: 0 auto;
	/*2й способ*/
	flex: 0 0 100%;
	/* Сокращённая запись: flex-grow, flex-shrink, flex-basis; Применяется у дочерних элементов */
	width: 100%;
	/*Вроде как удобней задавать родителю в % что бы блок был резиновый. В px указывается непосредственно контенту 
							 Родителю указываются в px это min max размеры высоты и ширины что бы иметь хоть какие то рамки
							 Не мало важно что блок установленный на 100% ищет верх по структуре до ближайшего px размера 
							 */
	padding: 10px;
	/*display:flex выравнивание хорошо, но не даёт отступы. Не забываем ставить */
	margin: 0 auto;
	/*Не работает на inline и inline-block
		Ещё если при такой понадобиться делать отступ через margin то отталкиваться элемент будет
		от линии, а не от местоположения. Использовав padding элемент просто будет расти в ширь. 
		Выход отталкиваться от блока
	*/
	justify-content: center;
	/*Не заменяет свойство text-align т.к. свойство выравнивает контент с текстом, но текст
													 по прежнему прибит к левому краю. text-align: center решает эту задачу */
	float: left;
	/*Как работает float
		Не забываем что после установки свойства элемент выскакивает со всеми своими вложенностями на поверхность. 
		Если родитель держался только на этом блоке и так же родитель для какого-то элемента уже relative, то контент с 
		position: absolute тоже будет свёрнут т.к. он давно с наружи и держался.
	При использовании слайдера float лучше не использовать. Поведение не понятно.

	 У float поведение чем-то похоже на absolute, но со своими особенностями
	 Следующий после его блок займёт его место, контент в том блоке будет обтекать этот блок будто они на одном уровне.
	 Перемещать блок можно в лева и в права. С лева - обтекает с права, с права - обтекает с лева.    
	 
	 Оказывается float не работает с 1ми дочерними элементами от родителя flex 
	*/
	clear: right;
	/*Убирает обтекание*/

}


	/*Ещё один пример на просторах интернета. Представим блок в котором есть блок стрелка "В лево" "Блок" "В право"
		В html это примерно будет так

		<div class="box">
			<button class="left"></button>
			<div class="content">...</div>
			<button class="right"></button>
		</div>
	
		Выровнять как надо через flex и всё. Но смотрится это вроде не совсем правильно что-ли. 
		Можно сделать так:

		<div class="box">
			<div class="content">...</div>
			<button class="left"></button>
			<button class="right"></button>
		</div>
		
		Обычно так и делают, всякую мелочёвку скидывают ниже, да и не разбросано это теперь.
		И вот что бы это теперь выровнять придётся или менять местами это через css например через 
		свойство order во flex, или использовать grid с его template-area или числовое перемещение, 
		хотя и order там тоже есть или старым способом зарезервировав место через padding основным блоком,
		и задав ему position: relative, а кнопкам position:absolute
	*/
	.box{
		padding: 0 20px;
		position: relative;
	}
	.left, .right{
		display: block;
		position: absolute;
		top: 0;bottom: 0;
		width: 100%;
		margin: auto;
	}
	.left{ left: 0; }
	.right{ right: 0; }


/*-----------------------------------------------------------------------------------------------------*/
:root {
	outline: none;
	/*стандартное выделение. Рамка выше border*/
	box-shadow: 0 0 10px 20px black;
	/*оказывается есть необязательный параметр толщины 20px */
	/* Жаль что не принимает linear-gradient, но можно псевдоэлемент на bg кинуть фон и заблюрить */

	overflow: scroll;

	/*Для таблиц*/
	display: inline-table;
	display: table-cell;
	/*присваивает тип ячейки таблицы*/

/*
  1. Строки и tbody таблицы не обводятся border, не задаются размеры и отступы
     манипулировать можно цветом или переключать в любой режим: 
     строчный, строчно блочный, блочный. 
  2. Размеры задаются ячейкам. 
  3. Предложенные свойства для таблиц работают в html а не в css
  4. table bg покрывает весь фон, tbody bg покрывает фон всех ячеек
	5. table строчный хоть и где то читал что блочный. В Normalize указываю block
	6. tbody width: 100%; растянется на table,  td - (НЕ tr и даже не th) растянется на ширину tbody если задать width: 100%;
*/



}
/*########---------<{ FLEX BOX }>------#########
	1. По умолчанию дочерние элементы принимают форму самого высокого блока. Что бы
	   убрать это состояние нужному дочернему присваивается align-self: baseline; или start
*/
.parent .child {

	flex-basis: 50%;
	/*По ум. auto. Управляет базовым размером блока. Если стоит flex-direction: column; то управляет
								 высотой, в другом случае шириной. Установив дочернему flex-basis: 500px; родитель всё равно распределит свой
								 размер на все дочерние элементы одинаково(если хватит на каждый по 500 то будут 500 если будет меньше то блоки сожмутся)
								 Установив flex-direction: column; то высота дочернего блока будет 500px.
								 Итого: flex-basis просто задаёт базовый размер. Это практически как max-width, но работает с flex.
								 max-width не может быть полной заменой т.к. с манипуляциями flex-grow или flex-shrink свойство max-width может отвалиться
	Сколько % должен занять блок в родительском блоке*/
	flex-grow: 1; 
	/*По ум. 0. Смахивает на единицу fr но, работает это пока нет контента. Добавив контент в блок 2й блок без него сжимается на
							ШИРИНУ пустого пространства 1го блока с контентом. Пример:
								|контент...;    Ширина пустоты   |		Ширина пустоты		|.
							Есть пара способов как это решить. Об этом ниже. Вообще flex-grow можно по всякому заменять используя на дочерних элементах
							тот же flex-basis распределяя 100%; или тот же width в %. Иногда можно воспользоваться заставив блок растянутся на оставшуюся ширину.
							*/
	
	flex-shrink: 0;/* По ум. 1. Отвечает за степень сжатия блока.. Тот же стиль как у flex-grow но на сжатие.  flex-shrink: 0; не сжимать блок.*/
}

/*Чуть подробней о flex-grow*/

/* 1й child1 с контентом. блоки не будут занимать теперь по 50%. решения. */
.child1{
	/*-----вариант 1----------------------------------------------------------------------
	flex-grow:1; */
	flex-basis: 50%;/* 2блока flex-basis по 50% + на родителе flex-wrap: wrap на телефоне блок2 может перенестись вниз 
										 если стоит на блоках border или что-то видимо случилось*/
	/*-----вариант 2----------------------------------------------------------------------
		...  */
	/*-----вариант 3----------------------------------------------------------------------
		...  */
	/*-----вариант 4----------------------------------------------------------------------*/
	width:50%;
	/*-----вариант 5----------------------------------------------------------------------*/
	flex-grow: 1; 
}
.child2{
	/*-----вариант 1----------------------------------------------------------------------
  flex-grow:1; */
	flex-basis: 50%;/*не прокатит если flex-basis: 50%; указать только child2. Потребуется тогда вариант 2.*/

	/*-----вариант 2----------------------------------------------------------------------*/
	flex-basis: 50%;
	flex-shrink: 0; /*в таком случае child1 можно не указывать flex-basis: 50%;*/
	/*-----вариант 3----------------------------------------------------------------------*/
	max-width: 50%;/*прокатит указать только child2 если в этом блоке много контента. Если контента мало
									 не сжался*/
	flex-grow: 1;/*то что бы блок child2. Но опять же, если контента в child1 больше и нет ограничений на ширину в 
								child1, то flex-grow не спасёт и child2 сожмётся */
	/*-----вариант 4----------------------------------------------------------------------*/
	width: 50%;/*универсальный способ задать блокам размер. flex блоки стоят в ряд это в основном то что надо. 
							 Не нужно думать будет ли контент в каком-то блоке или нет здесь жёстко ограничили*/
	/*-----вариант 5----------------------------------------------------------------------*/
	max-width: 50%;/*или width: 50%. Смысл заключается в том что б не лазить в child1, но всё же если в child1 не будет контента
									 то child1 сожмётся. Поэтому можно туда установить flex-grow: 1;*/
	flex-shrink: 0;/*выключили сжатие блока. даже если нет контента блок будет растянут до его ограничивающего предела*/
}
/*
	Итого: flex-grow рассчитан на заполнение блоком лишнего пространства при условии что ничего не мешает 
				 и размер блока регулируется контентом. 
				5й вариант не плох
*/




/*в данном варианте flex-basis и flex-grow делают одно и тоже.
flex-basis нужно просто 100% распределять по элементам. flex-basis тот же max-width или max-height, но заточен на 
flex т.к. max-width или max-height c flex не очень работает.
*/
.parent{
  display: flex;
  width: 100%;
  height: 200px;
}
.child1{
	/*блок не растянется даже*/
  max-width: 100px;
}

.child1{
	height: 20px;
	background: gray;
	flex-grow: 1;
	flex-basis: 50%;
	
}
.child2{
	height: 20px;
	background: darkgray;
	flex-grow: 1;
	flex-basis: 50%;
}

/*
	flex-grow и flex-shrink это 2 противоположных свойства. используются как таковой отдельно
	и работают они с шириной дочернего элемента которая устанавливается или через flex-basis или
	через max-width;  
*/
/*child1 не будет сжиматься, child2 будет в 10 раз быстрей сжиматься.
	Но работает это если установлено статичные значения, потому что %
*/
.child1{
	flex-basis: 300px;
	flex-shrink: 0;
}
.child2{
	flex-basis: 300px;
	flex-shrink: 10;
}

/*
	Как сделать так что бы текст сжимался пропорционально?
	Текст сжимается пропорционально относительно viewport. Сжимать текст нужно тогда когда 
	container занимает размер viewport. То есть это нужно делать в медиа запросах.
	Можем столкнуться с такой проблемой когда текст сжимается а блок нет, это значит мы не правильно
	используем flex и max-width.
	Нужно изначально без медиа на дочернем блоке подогнать размер под текст используя flex-basis,
	а потом использовать в нужный момент wv для текста 
	Пример:
*/
.main__title-box{ 	display: flex; 	}
.main__title { 	flex-basis: 60%;	 }

@media (max-width: 1070px) {
	.main__title{		font-size: 5.3vw;		}
 }
/*ВАЖНО: Вот пример когда flex-basis не подошёл. Нужно было 1ю ячейку на 100% вытянуть
 остальные по 25% на 2й строке. В итоге на телефоне flex-wrap: wrap; перекидывал на 3ю строку.
*/

.table__row{
	display: flex;
	flex-wrap: wrap;
}
.table__cell:nth-child(1){
	flex-basis: 100%;
}
.table__cell + .table__cell{
	flex-basis: 25%;/*на телефоне были траблы+*/
	width: 25%;/*подошёл просто размер*/
}


/*--------------------------------------------------------------------------------
########--------<{ Селекторы отношений }>---------#########

X > Y (родитель > дети) предназначен для выбора элементов, определяемым селектором Y непосредственно 
       расположенных в элементе, определяемым селектором X.

input + label выберет все элементы label, которые расположены сразу же за элементом input, 
         и являющиеся друг по отношению к другу соседями (сиблингами).
p ~ span выберет все элементы span, расположенные после элемента p на том же 
         уровне вложенности.

Вроде input не содержит ::after и ::before поэтому заворачивают в div
*/

/*
	<div class="wrap">
		<span class="slider__btn slider__btn--left"></span>
		<span class="slider__btn slider__btn--right"></span>
	</div>

	У элементов может быть 2 класса общий и индивидуальный, обращаться к индивидуальным классам
	через общий не всегда приходиться, но если придётся то между ними не должно быть промежутка.
	Обращение от класса к классу имеют больший приоритет чем просто обращение через 1 класс. 
	Иногда это надо что бы перебить свойства
*/

.slider_pages__item.is_active{} /*эти свойства в is_active отработают если 2 класса на одном элементе

	<div class='slider_pages__item is_active' ></div>*/

.slider_pages__wrapper .is_active{} /* is_active отработает если в дереве html будет вложенность

		<div class='slider_pages__wrapper' >
				И рядом или где-то там 
				<div class='is_active'> </div>

		</div>
*/

/*в отличии от обращение от родителя к дочернему*/

.parent>.child
/* Обращение к дочерним элементам.  почти тот же li ul*/
.child1+.child2
/*выбирает соседа*/
.child1~.child
/*выбирает всех соседей*/

p:first-child {}

/* все 1е <p> в каждом родителе*/



.myClass:target {
	/*Отработает если была нажата где-то ссылка в атрибуте которой передан именно id
	блока у которого ещё и класс myClass. 
		<a href="#myId"></a>
		<div id="myId" class="myClass"></div>
		Что-то типа label для input
	*/

}

/*Вроде нужная штука при разработке модальных окон.  На заметку если неправильно привязать модальное окно,
	1. При закрытии окна если мы будем находиться внизу, окажемся снова на верху сайта. Привязывать нужно 
			к элементу который ходит за нами. (Header например) или зафиксировать пиксель 
	2. Что бы страница не перезагружалась в close ставят href="#" но при клике она будет в url
При таком подходе на css скролится задний контент и url заполняется не нужным хламом. Лучше делать на js.
Так же не забываем что организовать крестик можно через checkbox
*/


.myClass:not(:first-child) {/*всех кроме 1 элемента*/
	display: flow-root;
}


/* Пример на реальном проекте в React:
<body class="theme-light" >
	... где-то там есть кнопки
		  <Button onClick={toggleDarkMode} className="header-icon-4 show-on-theme-light"><i className="fa-moon"></i></Button>    
    	<Button onClick={toggleDarkMode} className="header-icon-4 show-on-theme-dark"><i className="fa-sun"></i></Button>   
</body>
*/
/*При изменении всего лишь одного класса на body мы получаем как бы условие: 
	"Если в структуре DOM встречается такая цепочка, то к последнему применить данные свойства"
	То есть прячем одну кнопку и показываем другую, при изменении класса на body в theme-dark 
	получаем другие связки 
*/
.theme-light .show-on-theme-light{/*начальный класс в body theme-light*/
	display: block;
}
.theme-light .show-on-theme-dark{
	display: none;
}
.theme-dark .show-on-theme-dark{/*по клику изменим body в theme-dark и классы на кнопках отработают*/
	display: block;
}
.theme-dark .show-on-theme-light{
	display: none;
}



/*--------------------------------------------------------------------------------*/
select {
	padding: 0 10px;
	/*
		Обычно у input делают отступы слева и справа. У select отступ с лева делается, а с права нет, стрелка справа 
		останется на своём месте. Иногда требуется стилизовать стрелку, да и вообще input.
		Можно стилизовать чрез тег label привязав input после его скрыть или убрать вовсе 
	*/

}




/*При построение списков видел такой приём. Структура как обычно <li><a></a></li> Предположим ссылки имеют border. li находятся
  плотно друг к другу и стили им не присваивали. Ссылки тоже будут плотно прижаты. Я бы делал разрыв примерно так*/
nav .li {
	margin-right: 10px;
}

nav .li:last-child {
	margin-right: 0px;
}

/*Вот видел такой прикол*/
nav .li+.li {
	padding-left: 10px;
}

/* 1. Блоки li остаются плотно т.к. отступ внутренний, но из-за того что нет стилей видимо и так сойдёт
	 2. Действительно как я раньше не допёр исключать таким образом 1й элемент от ненужного указания свойств
			Заменяет такую запись 
			nav li:nth-child(1n + 2){ padding-left: 10px; }
			(an + b), где a и b целые числа, n — счетчик, который автоматически принимает значение 0, 1, 2.
*/
/*
	При такой структуре <li><a></a></li> если <a> задать внутренний отступ то границы будут вылазить за пределы <li>
	ВАЖНО нужно всегда указывать ссылкам display: inline-block или block.
	Как по мне лучше забыть использовать стиль обычного display: inline; Слишком много гемороя вылазит из этого свойства
*/


/*При наведении за ранее зарезервировать border*/
nav .li a {
	border: 1px solid transparent;
}

nav .li a:hover {
	border: 1px solid rebeccapurple;
}

/*градиент на border. Градиент накладывается по всем 4м частям border не зависимо сколько отображаем
	так что нужно показать все border, настроить градиент и убрать ненужные */
.item{
  border-bottom-width: 5px;
  border-bottom-style: solid;
  border-image: linear-gradient(#0B0E7F , #0B95DD);
  border-image-slice: 1;/*без этого свойства не выйдет*/
}



textarea {
	resize: none;/*убирает возможность изменять размер*/
	resize: vertical;/*оставляет только вертикальное изменение размера*/
	padding: 10px;
	/* не забывать делать отступы у */
	position: absolute;
	/*поднимает блок по z координате на 1 шаг. по ум привязывается к окну браузера */
	/*
		Если элементу выше было задано left: 0, то вроде при попытке задать right значение оно неохотно будет 
		применяться, для этого задать left: auto;
	*/
	left: auto;
	right: 20px;
}

/*########-------<{ Заметки }>--------########
 


	

	При использовании position: absolute не забываем что элемент находиться на поверхности и 
	если предусмотрен контент на блоке над которым с позиционирован этот элемент, то нужно накидать 
	контента и проверить не будет ли контент залазить под этот элемент и сделать нужные padding отступы 
	контенту 
	 	
	Если задаётся float дочернему элементу, то родителю можно задать clear: both и вроде как блок не будет вылезать за родителя   

	3 колонки имеют разное наполнение текста имеют так же кнопки. Что бы кнопки не были на разных уровнях один из вариантов,
	задать колонкам relative, сделать отступ с запасом, кнопкам задать absolute и выставить bottom на нужную высоту

	Если в свойстве position использовать 2 свойства left 0 и right 0 то блок встаёт по середине. По вертикали тоже самое.
	Таким образом элементы находящиеся в этом блоке встанут по середине и между ними можно сделать отступ тогда они будут отталкиваться 
	друг от друга.

	При подключении других библиотек возможно понадобиться изменить поведение. Как вариант смотреть классы в действии и переопределять
	
	Подключение локальных шрифтов + Препроцессор SCSS.
		При подключении шлифтов имеем файл scss где прописаны шрифты и их путь, так вот путь нужно учитывать не относительно
		_fonts.scss а относительно файла style.css потому что к шрифтам он обращается а не scss 
	

	opacity - если элемент имеет псевдо элементы они так же скроются
Адаптивная высота

	2. svg без статичного размера может не реагировать на max-width: n px; нужно задать ещё width: 100%;
	3. Пропорциональное изменение высоты блока относительно ширины. Работает это через родителя или псевдо элементы. 
			Нужно узнавать ширину динамически, а это может делать padding, но он обычно высчитывает относительно экрана или relative.

		Родителю задаём
				position: relative;
				max-width: 22rem; - какую-то ширину
				width: 100%; - это чтоб по любому растянулся блок на ширину т.к. не везде растягивается.
				background-color: transparent;
				
		псевдо элементу или дочернему если есть обёртка
				position: absolute;
				padding-bottom: 5.6rem * 100% / 22rem; -	Формула:  желаемая высота до трансформации * 100 / на ширину родителя т.к при его сужении будет меняться наш блок.
				left: 0; right: 0; bottom: 0; top: 0;

				текст придётся выравнивать через line-heigth 
		 Работает это через padding-top/bottom, а блоку задаётся height: 0;
*/


/*
	с дочерним элементом padding должен иметь родитель, тогда дочерний будет подстраиваться.
	Печально то что при таком подходе не работает flex так как мне надо в слайдере не будет выталкивать элементы


*/



/* Случай когда мы знаем что у предка по отношению родителя 1170px*/
.parent{
	position: relative;
	padding-bottom: calc(400px * 100 / 1170px);
}
.item{
	position: absolute;
	top: 0; left: 0; right: 0; bottom: 0;
}
/*иначе*/
.ancestor{
	width: 500px;
	position: relative;
}
.parent{
	position: absolute;
	padding-bottom: calc(400px * 100% / 100%);
}
.item{
	position: absolute;
	top: 0; left: 0; right: 0; bottom: 0;
}

/*
	ВАЖНЫЙ момент. Если parent находиться в блоке у которого ширина 1170px и если есть padding, то 
	его нужно учитывать.
*/
.ancestor{
	max-width: 1170px;
	padding: 20px;
}
.parent{
	position: relative;
	padding-bottom: calc(400px * 100% / (1170px - 40px));
}
.item{
	position: absolute;
	top: 0; left: 0; right: 0; bottom: 0;
}


/*ВАЖНО: выше описанную формулу можно не особо использовать. 
	Если хотим что бы блок сжимался когда его уже настиг viewport то просто на этой точке высоте задать
	размер в vw. Блок будет менять высоту пропорционально ширине.	
*/

.parent{ height: 5vw; }




/*#####----<{ Использование повторяющих элементов с использованием GRID }>---->>>>>>*/
/* Создав в тексте псевдо элементы без position свойство text-align: center будет
	 выравнивать не только текст, но и эти элементы, от чего сам текст перекоситься*/

/*При попытке наследования классов для дублирования стилей, убедиться что нужные стили находятся в этом
	классе, а не наследуют свойства от родителя
	Пример:  */
.advantages {
	display: grid;
	grid-template: auto / 1fr 1fr 1fr 1fr;
	grid-column-gap: 5rem;
	font-family: 'MyriadPro-Regular', serif;
	padding: 3.5rem 0;
}

/*Я хоть и создал как title как блок, но для секции не все свойства будут работать*/
.title-two {
	grid-column: 1 / -1;
	justify-self: center;

	font-size: 2.8rem;
	text-transform: uppercase;
	color: #303770;
	text-align: center;
}

/*1. имя шрифта или поднимать выше или добавлять в title
		2. Другая секция наследует title-two и title будет искать у родителя grid инициализацию,
			 а её в этой секции нет. 
			 И вот дилема: сетку выше поднимать смысла нет иначе влияние grid будет перенесено на верхние блоки.
			 Нужно создавать title таким образом что бы он был привязан к другим свойствам.


			 Остаётся в таком случае оборачивать title блоком, сам h2 будет элементом, сам блок должен влиять
			 только на текст, а не распространять свои свойства на
	*/




	/*------- Немного о button -------
		Несмотря на то что кнопке установили display: block она не будет растягиваться на всю длину,
		что бы её растянуть нужно сделать так: */
	
	button{
		display: block;/*Если хотим выравнивать margin: 0 auto иначе убрать и родителю text-algn: center;*/
		max-width: 200px;
		width: 100%;
	}

	/*--------------------------------*/





/*####-----<{ Затемнение видео }>----->>>>>>> */
.parent {
	position: relative;
}

.patent::after {
	/*...*/
	position: absolute;
	top: 0;
	background: rgba(0 0 0 .7);
	z-index: -1;
}

.video {
	position: absolute;
	z-index: -2;
	width: 100%;
}

/*----------------------------------------*/












/*#########------<{ Использование :before :after }>-------############*/
.slider__btn::before {}

/*ДО*/
/*Запомнить просто. before слово длинное, но короткое значение */
.slider__btn::after {}

/*ПОСЛЕ*/
/*
	Элементы инлайновые. Что бы появился мало задать размер и цвет. display: block/inline-block
	
	Позиционирование элемента относительно блока обычно делают так:
*/
.item {
	width: 300px;
	height: 300px;
	position: relative;
}

.item::before {
	content: '';
	position: absolute;
	width: 30px;
	height: 30px;
	margin: auto;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
}

/*
	Если нужно растянуть увеличивают размер. 
	Есть способ как убрать размер и центрирование и растягивать через стороны.
	Если надо поместить в середину то ищем середину большого квадрата и маленького 
	300/2=150px т.к. это квадрат, то 150px актуально для всех сторон.
	30/2 = 15px.  Теперь 150 - 15 = 135px для сторон. Вообщем как занавеску вещать, отступ прикидывается
	от стены.
	
*/
.item::before {
	content: '';
	position: absolute;
	top: 135px;
	bottom: 135px;
	left: 135px;
	right: 135px;
}

/*-------------------------------------------------------------------------------------------------*/
/*########------<{ Практические казусы }>----------------------------------------------------------*/
/*БОЛЬШАЯ ОШИБКА делать так. Предположим у 2х элементов общий класс и отдельные свои классы.
<span class="slider__btn slider__btn--left"></span>
<span class="slider__btn slider__btn--right"></span>
Как НЕ СТОИТ делать
*/
.slider__btn::after,
.slider__btn::before {
	content: '';
	width: 10px;
	height: 10px;
	content: '';
	width: 10px;
	height: 10px;
	display: flex;
	justify-content: center;
	align-items: center;
}

.slider__btn--left::before {
	/*Этот before не будет по середине. Квадрат будет смещён потому что рядом 2й квадрат от after тоже в 
		середине стоит скрытый */
	border: 1px solid #000;
}

/*
	Кстате такая схема использования псевдо элементов иногда пригождается, когда выкрашивается линия под кнопками общей краской, и потом 
	перекрашивается у отдельных элементов. before тот де просто через другое имя класса. 
*/






/*Правильный вариант. Но за ранее скажу что делать стрелки из бордера потом переворачивать на 45 и 135 градусов, и пытаться выровнять
	через flex. Они не окажутся по середине, верней ось квадрата по середине как полагается когда мы разворачиваем получаем ромб и оставляем одну 
	из частей она остаётся на своей стороне часть ромба и нам надо что бы она уехала на середину со своей стороны.
	Вот как довольно точно выровнять. И делать нужно именно в таком раскладе. не правильная установка translate будет не так высчитывать
*/
.slider__btn {
	width: 50px;
	height: 60px;

	margin-left: 20px;
	border: 2px solid darkorchid;
	display: block;
	position: relative;

}

.slider__btn::before {
	content: '';
	--border: 3px;
	width: var(--sliderArrowSize);
	height: var(--sliderArrowSize);
	border-top: var(--border) solid #000;
	border-left: var(--border) solid #000;

	position: absolute;
	top: 50%;
	left: 50%;

}

/*сдвиг на 4ю часть квадрата*/
.slider__btn--left::before {
	transform: translate(-25%, -50%) rotate(-45deg);
}

.slider__btn--right::before {
	transform: translate(-75%, -50%) rotate(-225deg);
}




/*----------------------------------------------------------------------------------------------------------*/
/*#########----<{ Градиенты }>----#########*/
.box{

	background: radial-gradient(circle farthest-corner at 100px 50px, #FBF2EB, #352A3B);	
	/*	Градиент подойдёт для указания пятна света. Мягкий и плавный переход
		1й.по ум. ellipse, 
		2й может не указываться - это положение пятна 
									Перемещая точку градиента используя:
						closest-side	Размер градиента рассчитывается из расстояния до любой ближней стороны блока для circle или до ближних сторон по X и по У для ellipse.
						farthest-side	Размер рассчитывается из расстояния до дальних сторон.
						closest-corner	Размер увеличивается или уменьшается в зависимости от расстояния до верхних углов
														данного блока.
						farthest-corner	Размер рассчитывается из расстояния до дальних углов.
*/
/*Этот градиент может использоваться для круглых диаграмм. 
	Начало линии цвета по ум. с центра и верхней грани. Цвета устанавливаются по часовой.
	Каждому цвету можно задать точку начала цвета.
*/
	background: conic-gradient(red 50%, orange, blue, green); 
		/*Можно задать точку смещения с центра куда либо задав at X Y*/
	background: conic-gradient(at 50% 25%, yellow, lime, blue, violet, red, yellow);
}


/*-------------------------------------------------------------------------------------------------------------*/
/*#########----<{ Необычные свойства }>----#########*/
.el {
	background: url('../img/image1.jpg') 250px /cover no-repeat,
		url('../img/image2.jpg') center /cover no-repeat;

	background-blend-mode: lighten;/*Определяет режим наложения. свойство работает в одном блоке. под одним background должно указано 2 картинки или картинка и цвет */
	isolation: isolate;	/*Что-то про контекст наложения. связан с blend-mode. Почитать*/

}

.el {
	width: 500px;
	height: 300px;
	background: wheat;
}

.el__child {
	background: url('../img/image1.jpg') center /contain;
	/* 

background-size подстраивает картинку под размер блока. По умолчанию блок и картинка сами по себе. Если картинка большая она тупо выйдет за пределы
								это background скрола не появиться.
								100% auto; - уместить картинку по ширине блока, высота как уж карта ляжет
								auto 100%; - автоматически уменьшит картинку пропорционально своему размеру подстраиваясь под высоту блока.
														 Пример блок h300px. Картинка тож будет 300px(100%) но и в ширину не размажется, а пропорционально подгонит размер.
														 Короче пропорционально будет увеличивать (грубо) бесконечно картинку по ширине если увеличивать высоту блока под который она
														 подстраивается.
								100% 100% - ручное управление пропорциями картинки
							
								contain - поведение чем-то похоже на auto 100%, но нет. contain будет растягивать до тех пор, пока одна из 
											    наименьших сторон блока не встретит	растягивающуюся пропорционально картинку.
								cover -  растягивает изображение пропорционально своим размерам до тех пор пока не встретит ограничение
												 блока в котором находиться. В роди ограничения наибольшая сторона блока.
												 		  
	
													
	contain растянет на весь блок ориентируется по ширине изображение, cover по высоте */
	width: 100%;
	height: 100%;
	mix-blend-mode: luminosity; /*ВАЖНО: При использовании transform свойство спадает*/
	/*Определяет режим наложения. Работает уже относительно родительского background или цвета или image */
	/* в обоих случаях изображение или цвет можно менять местами */


}

.parent {
	-webkit-text-stroke: 4px red;
	/* толщина и цвет обводки текста. Через svg и stroke-width можно добиться того же результата */
	/* Обычно толщина обводки подгоняется через text-shadow: и километровый код*/
}


/* Можно тексту задать градиент. Пока нормального свойства нет для этого и делают это так:*/
.box{
		background: linear-gradient(20deg, #303770 20%, #3fc640);	/*блок текста выкрашиваем градиентом*/
		
		-webkit-text-fill-color: transparent;	/*делаем текст прозрачным. Можно остановиться тут используя на фоне картинку */
		-webkit-background-clip: text; /*вырезает весь задний фон, текст остаётся с его градиентом*/
	
		/* Как можно каждой строке задать фон(цвет везде один), так что бы было видно промежутки между строк.*/

		-webkit-box-reflect: below 10px linear-gradient(transparent, #0008);/*создаёт отражение текста. 1й режим, 2й расстояние*/
}
select{
	appearance: none;/*свойство скрывает стандартные стили input*/
	pointer-events: none;/* Реакция на ивент мыши. если требуется нажимать на блок, но сверху его прикрывает другой блок, то указав ему это свойство он будет
													игнорироваться (сквозь)*/
}



/*---------------------------------------------------------------------------------------------------------------*/
/*#########----<{ Разница позиционирования img или background-image в div }>----#########*/
.item{
	background-image: url();
	background-size: cover;
	background-position: center;
}
/*разница лишь в том что у картинки должен быть по-любому размер иначе object-position не сработает.(не в display: block; дело)*/
img{
	width: 100%;
	height: 100%;
	object-fit:cover;
	object-position: center;
}








/*-------------------------------------------------------------------------------------------------------------------*/
/* #########-------<{ счётчик на css }>--------########## */
body {
	counter-reset: myCount;
	/*определение как бы в глобальной области переменной счётчика*/
}

.item::before {
	counter-increment: myCount;
	content: counter(myCount);
}

/*########--------<{ Единицы измерения }>--------############*/

div {
	width: 100vw;
	/*добавит нижний скрол, а % нет.*/

}

.text {
	font-size: 10;

	/*
Чаще всего стандартно браузер выставляет 16px. Свойства для текста наследуются. px всегда наследуют ближайшее значение родителя. 

	rem - всегда смотрит на html или :root{}.  Если в html или в :root{} не установлен начальный размер, то rem будет работать относительно
				стандартно заданного числа 16px в браузере.
				Плюсы использования: можно задавать значение в html 20px и везде использовать rem
				и в дальнейшем в медиа запросах достаточно будет изменять rem в html и везде шрифт будет изменяться.
		
			 Советчица говорит не делать так: 
			 :root{font-size: 0.625em } или 10px  .text{ font-size: 1.4rem } = 14px - удобно вычислять, 
			 1. проблема в том если не использовать наследование, то много где придётся переопределять значения
					<div> первый уровень //наследует ближайшего родителя px или 10px
						<div> второй уровень </div> //наследует ближайшего родителя px или 10px
						<p class="text"> Lorem ipsum dolor sit </p>// 1.4rem = 14px
      		</div>
					<div> первый уровень </div>//наследует ближайшего родителя px или 10px
					
				Но вообще-то уже не плохо. Если использовать наследование.

					<div class="text"> первый уровень //1.4rem = 14px
						<div>  второй уровень </div> //14px
						<p > Lorem ipsum dolor sit, amet consectetur adipisicing elit. Earum, magni </p>//  14px
      		</div>
					<div> первый уровень </div>//10px
					
					Предлагает ещё больше заморочиться и научиться использовать em 


	em - Разница между rem и em в том что rem в любой вложенности заставляет элементы смотреть на html или :root{}, получать
				там значение в px(любые единицы переводятся в px) и умножает на rem наследованный rem. 
				em же заставляет брать элементам ближайшее родительское значение px и умножает на em. 
				em какой-то не предсказуемый. С разными тегами именно во вложенности он по разному себя ведёт. 

				Во вложенных списках такая ситуация: 
					к примеру наследует 16px где-то выше, в 1м ul указываем 1.2em, 16*1.2=19,2px,
				  2я вложенность ul уже наследует 19.2px, em то же наследует.19.2px* 1.2 = 23.04px и т.д
						Так растёт fz в каждом последующем списке.		  

						Проблемы.
				1. Нужно чётко следить сколько пикселей наследует блок(родитель) в котором хотим менять значения на em. Конечно же если манипулируем ещё пикселями.
				2. Явление роста или уменьшения шрифта во вложенных списках друг в друга.(в div нет такого) 
				3. <p> не наследует em. умножает свой em на ближайшие px, а вложенность наследует px не этого родителя, а выше

				Пример: 16px в body. Где-то 1я вложенность наследует 16px и указано в ней 1.2em, 16*1.2=19,2px, 2я вложенность 
								наследует 19.2px, а раз указано в родителе em то его наследует.  19.2px* 1.2 = 23.04px и т.д
								ТАКОЕ ПРОИСХОДИТ ТОЛЬКО СО СПИСКОМ.


	Вся фишка в наследовании px от определённых свойств(не все наследуются) и em. font-size наследуется прямо в блок  
	и px становятся локально доступными, но сначала отрабатывает font-size em*px и что получиться, то и будет локальным значением 
	для других свойств. Можно пропорционально увеличивать элементы. В принципе это так же делается через rem. 

	

		.wrap{
			font-size: 20px;
		}

	<div class='wrap'>
		<button class="btn">Кнопка</btn>
	</div>
		.btn{
			padding: 1em;
			font-size: 1em;
			border-radius: 1em;
		}
	
	% - через проценты можно так же как и rem сделать, но придётся манипулировать большими значениями т.к. 100% это то число которое в 
			body.
	wh - viewport width, 1wh/100(0.01) ширины: 1920 * 0.01 = 19.2px
	vh - viewport hight, 1vh/100(0.01) высоты 1080 * 0.01 = 10.8px
	vmax - 	
	vmin - 

*/
}

/*##########--------<{ Нижняя полоса }>---------############*/
/*Строиться через after. Подвинуть не отталкивая текс можно как минимум 2мя способами translateY или absolute/relative top;*/
::after {
	content: '';
	width: 100%;
	height: 3px;
	display: block;
	transform: translateY(2px);
	background-color: red;
}

/*############--------<{ Полосы по краям текста }>-----------############*/
/* Выравнивание полос к центру текста далее отступаем в разные стороны.
	Минусы: т.к. это position то при сужении элементы будут выходить за блок
					всё контролировать нужно в ручную.
*/

.header__title {
	/*... стили шрифта*/
	position: relative;
	text-align: center;
}

.header__title::before,
.header__title::after {
	content: '';
	/*ключевые свойства*/
	width: 10.7rem;
	height: .8rem;

	display: block;
	position: absolute;
	top: 50%;
	left: 0;
	right: 0;
	margin: 0 auto;
}

.header__title::before {
	transform: translate(420px, -50%);
}

.header__title::after {
	transform: translate(-420px, -50%);
}

/* Пробую подход через grid где можно создать сетку под полоски и текст */






/*-----------------------------------------------------------------------------------------------------------*/
/*#########-----<{ Стилизация scroll }>-----########*/

/*- вся полоса прокрутки.*/
::-webkit-scrollbar {

} 
/*- кнопки на полосе прокрутки (стрелки указывают вверх и вниз).*/
::-webkit-scrollbar-button {

} 
/*- перетаскиваемый маркер прокрутки.*/
::-webkit-scrollbar-thumb {

} 
/*- трек (колея) полосы прокрутки.*/
::-webkit-scrollbar-track {

} 
/*- часть дорожки (индикатор выполнения), не закрываемая ручкой.*/
::-webkit-scrollbar-track-piece {

} 
/*- нижний угол полосы прокрутки, где встречаются горизонтальная и вертикальная полосы прокрутки.*/
::-webkit-scrollbar-corner {

} 
/*- перетаскиваемый маркер изменения размера, который появляется в нижнем углу некоторых элементов.*/
::-webkit-resizer {

} 

/*####-----<{ Создание 3d свойство transform }>-----########*/

.parent{
	transform-style: preserve-3d;/*по ум. flat - 2d. Если прикрепить к блоку изображение и попытаться развернуть его по Y или X то мы отразим лишь изображение,
																 если установить preserve-3d - то ничего на другой стороне не увидим т.к. там новый
																 холст в который так же можно что-то положить. Аналогия: развернув в руке одноцветную карточку с изображением на одной стороне
																 мы же не увидим отражение на другой стороне
											ВАЖНО: Не запутываться с переворачиванием родительского элемента и дочернего, ведь установив дочернему элементу и перевернуть
															родителя мы таже увидим отражение
		ВАЖНО: режим  preserve-3d перестанёт работать если установить сюда же:
						opacity < 1, overflow (кроме: visible, clip), filter(кроме: none), clip(: auto), clip-path(кроме: none),
						mask-image(кроме: none), isolation: isolate, mask-border-source(кроме: none), mix-blend-mode(кроме: normal)
	*/
	perspective: 1000px;
	perspective-origin: 10% 20%;/*управляет точкой в 3d по Z и ставиться родителю в отличие от transform-origin. Так же работает 
																совместно с perspective*/
}
/*
	Перспектива(perspective) - это расстояние от глаз человека до элемента(НЕ МОНИТОРА).До монитора расстояние контролирует только пользователь
														 сидящий перед ним, а элементом управлять в мониторе его дальностью можно и без пользователя.
														 Изображение по умолчанию на оси Z=0, то есть его разрешение 1к1 это значит если б монитор был бы 100см,
														 а изображение 1 см то можно было б хоть линейкой померить. 
*/
.child{
	backface-visibility: hidden;/*Свойство позволяет делать элемент невидимым, когда его обратная сторона обращена к зрителю*/
	transform: rotate3d(1, 1, 1, 45deg);/*вместо rotateX(45deg) rotateY(45deg) rotateZ(45deg).
																				Цифры в начале это - отношение углов. Например, код transform: rotate3d(2, 1, 0, 90deg); 
																				заставит объект повернуться на 90 градусов вокруг оси X и на 45 (90 * 1 / 2) градусов вокруг Y.
																				То же самое сделает и строчка transform: rotate3d(90, 45, 0, 90deg).*/
	transform: translate3d(x,y,z);
	transform-origin: x y;/*выставляет точку относительно которой происходит вращение объекта*/
	transform: matrix3d(n,n,n,n,
											n,n,n,n,
											n,n,n,n,
											n,n,n,n);

}
.el{
	/*Переход none в какое либо состояние не анимируется свойством transition*/


	transform: perspective();
	/*оказывается есть метод. Свойство transform работает только с блочными элементами*/
	transform: scaleX(-1);
	/*scale отвечает за масштабирование. Если задать отрицательное значение стороне будет уменьшение и снова увеличение, но в отрицательную сторону
														получается разворот, будто бы использовали rotateY(180deg) именно по оси Y */

	transform: skewX();
	/*делает скосы, блок становиться параллелограммом по нужным осям */
	/*Так же в свойство не будет работать если общему классу задать общее значение transform, а потом
		дочернему что-то езё дополнять указав снова это свойство
	*/
	transform: matrix(scaleX, skewY, skewX, scaleY, translateX, translateY);
	/*
	Свойство matrix заменяет несколько свойств трансформации. Единица не указывается, но должны знать в чём
	в каких единицах работают другие свойства что бы понять какие цифры писать.

	matrix (a, c, b, d, tx, ty)
	масштабирование. Число это множитель на размер блока
		a - в ширину. 1 - это нормальный размер, всё что меньше уменьшение, больше увеличение 
	наклоны параллелограмм. Число хрен знает как вычисляется, но это не deg. Использование skew с единицей deg даёт другие результаты при тех же цифрах 
		с -  Положительное значение наклоняет вверх, отрицательное вниз.
		b -  Положительное значение наклоняет влево, отрицательное вправо.
	масштабирование
		d - в высоту. 1 - это нормальный размер, всё что меньше уменьшение, больше увеличение 
	Смещение в пикселах. Единицу так же указывать не надо
		tx - Положительное значение сдвигает элемент вправо, отрицательное влево.
		ty - Положительное значение сдвигает элемент вниз, отрицательное вверх.
	Существуют формулы. Если интересно можно почитать
	*/
}

/*#######-----<{ Фильтры }>-----########*/

.parent{
	/*свойство работает только на дочерних элементах. на bg не влияет*/
	filter:	blur(10px) /*размытие*/
					brightness(100% или 1)/*яркость*/
					grayscale(100%)/*чёрно-белый*/
					hue-rotate(140deg)/*все цвета меняются на угол цветного колеса*/
					contrast(200px или 100% или 1)/*контраст*/
					invert(100%)/*инверсия цветов*/
					opacity(100%)/*прозрачность*/
					saturate(200%)/*насыщенность*/
					sepia(100%)/*черно-белый с жёлтым оттенком*/
					drop-shadow(0px, 0px, 0px, 1);/*тень*/

	backdrop-filter: blur(10px); /* влияет только на родительский блок */

}
