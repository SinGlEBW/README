/*
  1. В препроцессоре конкатенировать переменную в строку используется такой синтаксис  '#{}' немного от js
     отличается `${}`. В циклах опустить ''
  2. препроцессор в режиме compress не передаёт классы если они не заполнены

*/


/*##########--------<{ Вложенности }>---------#############*/
.block{
  padding: 10px;
  /* & это родитель */
  & > p{}//  равносильно body > p - обращение к 1му "p", а не ко всем вложенным "p"  
  span{}// .block span - вложенность 
  &.block__content{}// .block .block__content{} - вложенность
  &__text{}// обращение .block__text{}
  &:hover{}
}

.link{
  .block &{} //.block .link{}
}
/*-----------------------------------------------------------------------------------------------------
##########--------<{ Пример }>---------#############

  <div class="box">
    <div class="box__item box__item--one"></div>
    <div class="box__item box__item--two"></div>
  </div>

Не важно обращаюсь от имени родителя или стилизую класс индивидуально*/

.box{
  color: #000;
  &__item{
    color: #000;
    &--one{ color: cornflowerblue; }
    &--two{ color: crimson; }  
  }
  /*можно так писать, но опять же глазу неприятно и придётся самому дописывать слова т.к. подсказок нет*/
  font: {
    family: Arial;
    size: 24px;
  }
}
/* Результат в css вложенности не будет без указания в препроцессоре явного >*/
.box { color: #000 }
.box__item { color: #000 }
.box__item--one { color: cornflowerblue }
.box__item--two { color: crimson }

/*#######-------<{ Фишки использования наследования }>-------#######*/

.box{
  &__el {
    padding: 1rem;
    &+&{ /*Обращаюсь к .box__el + .box__el, то есть пропускаю 1й элемент. Есть нюанс. */
      background: rgba($color: #000, $alpha: .8);;
    }
  }
}
//нюанс
.box{
  & p{/*из-за наследования*/
    padding: 1rem;
    &+&{ /*это не сработает */
      background: rgba($color: #000, $alpha: .8);;
    }
  }
}


/*-----------------------------------------------------------------------------------------------------
#######-------<{ Переменные }>-------#######

  Переменные отличаются от css. Там используется
  :root{  --fz: 80px; } и далее
  .link{  font-size: var(--fz); }
  
*/
$fz: 80px;
.link{
  font-size: $fz;
}

$values: #ff0000, #00ff00, #0000ff;

/*в scss есть rest и spread ( ... ) как в js только с другой стороны*/
$color: red;/**глобальная*/

@mixin name($color: blue) {
  background: $color;/*$color - локальная*/
  $p: 14px !global;/*локальную переменную делает глобальной*/
}

.child{
  @include name/*Если не передана то будет локальная использоваться*/
}
/*-----------------------------------------------------------------------------------------------------
#######-------<{ Шаблоны }>-------#######

  Зачем писать по 100 раз. Есть 2 способа подключения шаблона через mixin или через %.
  Способ с % хорош тем что он не будет перемещён в css если он ни где не использовался, а если использовался
  то перемещаются его свойства и имя шаблона ни где не фигурирует.

  Шаблон обычным классом .nameTemplate будет создан в css так же как обычный класс и там где мы его подключаем
  в css перед селектором будет этот класс.
  Положение шаблона имеет значение.
*/
%nameTemplate{
  font-size: 20px;
  color: red;
}
.link:first-child{
  @extend %nameTemplate;
  width: 40px;
}

/*-----------------------------------------------------------------------------------------------------
#######-------<{ Миксины (примеси) }>-------#######

  Это обычные функции только синтаксис свой. Функция хороша тем что значения можно передавать.
  Укорачивает в какой-то степени код. Но честно сказать не очень удобно смотреть где-то в стилях
  на этот миксин и пытаться понять за какие свойства он отвечает. Придётся искать его и смотреть или грамотно ему дать имя.  
*/
@mixin myMixin($a, $b:#fff, $c...) {/*$c...   типа rest как в js только с другой стороны*/
  font-size: $a;
  color: $b;
  @content;/* миксин можно дополнить в процессе его вызова, но это будет только в вызываемом месте. Об этом ниже */
}
$values: #ff0000, #00ff00, #0000ff;
.test1{
  @include myMixin(25px, green, $values...);/*Показываю что есть такая возможно spread*/

  //Теперь о @content.
  //Типа дополнил.
  @include myMixin(25px, green) {
    background-color: #fff;
  }
}
.test2{
  /*очень интересно, но смысла дополнять миксин background-color: #fff; я не вижу т.к. вызвав его в другом
    месте дополнений не будет.*/
  @include myMixin(25px, green);
  /*Изначально в test1 можно было сделать так:*/
  @include myMixin(25px, green);
  background-color: #fff;
}
/*Зачем же тогда нужен @content? Для начала покажу как можно делать*/

/*кстате миксин может ничего не принимать и вызываться так же без скобок*/
.test{
  @media screen and (max-width: 768px){
    background: #000;
  }
}
 //т.к. @media вложен то можно сразу писать стили. Результат  
 @media screen and (max-width: 768px){
  .test{ background: #000; } 
}

/*@content можно использовать так: */

@mixin _768 {
  @media screen and (max-width: 768px){
    @content;
  }
}
.test{
 @include _768{
   background: red;
 } 
}

.test2{
  @include _768{
    background: blueviolet;
  }
}
/*
  Фигово то что писать @media хоть с mixin хоть без в разных файлах для разных селекторов scss не группирует результат 
*/

@media screen and (max-width: 768px){
  .test1{ background: #000; } 
}
@media screen and (max-width: 768px){
  .test2{ background: #000; } 
}

/* Нашёл библиотеку gulp-group-css-media-queries*/

/*
  миксины можно называть с _ или - и вызывать можно без разницы с каким символом.
*/
/*-----------------------------------------------------------------------------------------------------*/

/*#######-------<{ Математика }>-------#######*/
//не нужно использовать calc

//rem * % / px - так не работает. 
.block{
  width: (300px / 960px * 100%);//31.25%. 
  max-width: 500px;/*детали. максимальная это не значит что она такой будет*/
  width: 100%;/*вот теперь на максимальную ширину*/
  /*
   Иногда требуется узнать  сколько % блок в 300px занимает от родителя.
   Варианты.
   1. 960 / 100 = n   300 / n = результат% 
   2. 300px / 960px * 100% сокращённый вариант
  */
}

/*-----------------------------------------------------------------------------------------------------*/
/*#######-------<{ Условие и циклы }>-------#######*/


.block{
  $rand: random(24);// выдаст число в диапазоне до 24 
  
  @if($a > 2){

  }
  @else{

  }

// Числа от 10 до 19 будут присваиваться в $b
  @for $b from 10 to 20 {
    
  }

  @each $var in list {
    
  }
}



