body{
		/*#######---------<{ Grid свойства и методы }>--------########*/

/* 	
	1. Построение через grid подразумевает использование html в сокращённом виде, без лишних блоков обёртки, см. grid верстка.html 
	2. Процентное значение отступов padding и margin в сетке не указывать, т.к. разные браузеры по разному считают
	3. Основная часть управления элементами происходит из родителя, от части это даёт избежать лишних указаний классов в
		 css. В 1 файле css убирается 4096 селекторов.

*/

	/*
   auto-fill - автоматическое заполнение элементами (заданного размера) пока есть место в контейнере 
                работает как flex-wrap: wrap.Если minmax(100px, 200px) статичные размеры, auto-fill умещает
                только по max значению. Если задать max в единице fr minmax(100px, 1fr), то auto-fill умещает
                в минимальном размере и держит их в этом размере
               Если быть точней.
               Контейнер делиться на равные части заданного размера. 
                Сетка создаётся по факту (размера контейнера / на размер элемента). Если установлен minmax и его max значение 
                статическое, то сетка (размера контейнера / на макс размер элемента), если в единице fr:  minmax(100px, 1fr), 
                то сетка будет: (размера контейнера / на минимальное значение.) По мере уменьшения контейнера
                уничтожение лишних секций сетки. Как контейнер сталкивается с реальными элементами происходит перенос flex-wrap: wrap.
                элементы используют max значение 1fr до тех пор пока auto-fill делает перерасчёт (контейнер / на минимальное значение элемента)
                То есть если размер контейнера позволяет 2м элементам в минимальном размере находиться на одной линии flex-wrap: wrap 
                не произойдёт.
  
        
   auto-fit -  Визуально похоже что работает так же как auto-fill, до момента использования fr единицы в minmax(100px, 1fr).
               На самом деле работает это так. Сетка создаётся по факту имеющихся элементов и их размеров. То есть
               (кол-во эл. * максимальный размер). При уменьшении контейнер если он встречается с сеткой то сетка (размера контейнера / на макс размер элемента),
               Из за того что серка работает по факту кол-ва элементов то minmax(100px, 1fr) это сетка (контейнер /  max размер), а max 
               размер (контейнер / кол-во эл.) и того (контейнер / (контейнер / кол-во эл.))

               Всё что нужно вкратце знать: При использовании единицы fr в minmax(100px, 1fr),
                  auto-fill держит элементы в min значении, auto-fit в max значении.  У обоих flex-wrap: wrap срабатывает при min значении. 
            
   minmax() - При изменении размера контейнера, если элемент не влазит будет изменяется до минимального значения.
            используется для адаптива. Используя в связке с auto-fill, auto-fill будет пытаться умещать по максимальному размеру элемента
						будто минимально размера нет. auto-fit так же отработает. 
						
		
	Единица fr(фракции) 3fr 1fr 1fr. При общей ширине в 100px
	1я колонка будет занимать 3fr из 5 возможных
	100 / 3+1+1 = 20px (1fr) значит 60px 1я колонка
   
   	repeat(кол-во раз, размер); повторить 
    repeat( 2, 50px ); - 50px 50px   
		repeat( 2, 50px 70px ); - 50px 70px 50px 70px
		
	*/
/*-------------------------------------------------------------------------------------*/
/*#######-------<{ ОПРЕДЕЛЕНИЕ СЕТКИ и ЕЁ РАЗМЕРОВ }>--------#########*/
/*
	1. дочернему элементу можно и не задавать, я б сказал не нужно задавать ширину и высоту, т.к. всё задаётся через родителя
			в grid-template-rows/columns.

			Есть помарка. 
			Если указывать размер колонки статичный подгоняя под элемент вместо того что бы задать ему ограничение непосредственно
			у себя в блоке, то колонки будут не одинаковы и когда будем делать общее выравнивание или выравнивание элемента они выровняются по своим
			имеющимся колонкам. Так что лучше колонки задавать одинаковыми, управлять размеров объекта у себя в контенте и выравнивание по центру 
			будет точное как от родителя так и по отдельности. Об этом ниже.


	2. grid-template это родительское свойство, а не дочернее.
			По умолчанию колонки подстраиваются, под самую высокую расположенную именно в одном ряду. Пример ниже.
	3. Если каждую строку выравниваем по контенту наибольшей колонки, то смысла записывать 
		grid-auto-row: min(auto) или minmax(100px, auto) нет, auto уже делает своё дело
*/
	grid-template-rows: repeat(3, 250px);	/*кол-во строк и их высота*/
	grid-template-columns: 14rem  repeat(2, 1fr); /*любой сложности запись*/
	grid-template-columns: 500px 1fr;	/* ко-во колонок и их размер*/
	grid-template: grid-template-rows / grid-template-columns;/* сокращённая запись, для строк и колонок, но свойство принимать может и grid-template-areas */

	/*
		grid-template-... нужна когда знаем сколько колонок и строк. grid-auto-... когда не знаем. Тогда grid-template можно опустить
		Записав к примеру для строк:
	*/
	grid-auto-rows: minmax(100px, auto);/*например с сервера получать товары и строить так строки самое то*/
	
	grid-template-rows: repeat(3, 200px);/* ни кто не мешает их использовать вместе если какую-то часть строк конкретно задаём*/
	grid-auto-rows: 100px;

	/*
		grid-auto-rows устанавливает размер всем строкам. Удобно тем что если текст прибавится в 1 карточке и сдвинет кнопку ниже, но на одном уровне кнопки так же сдвинуться
		grid-auto-columns используется без 	grid-template-columns 
	*/

	
	
	grid-auto-flow: row;/*это тот же flex-wrap: wrap.   Если выбрано column, то тот же no-wrap*/
	/*
		Иногда можно пользоваться grid-auto-flow вместо создания grid-template-columns, то только в том случае если
		дочерние имена имеют размер иначе их как-то нужно ограничить, что собственно не делает grid-auto-flow
	*/


	grid-template-columns: repeat(auto-fit, minmax(0, max-content)); 
	justify-content: space-between;

	/* Можно задавать произвольные имена началу и концу колонкам или строкам. Об этом ещё ниже.*/
	grid-template-columns: [col1] 1fr [col2] 1fr [col3] 1fr;/*можно задавать имена*/
	grid-template-columns: [col1-start] 250px [col1-end col2-start] 1fr [col2-end col3-start] 1fr [col3-end];/*можно создавать метки начала и конца*/
/* Задавать таким образом имена не продуктивно*/
	


/*-------------------------------------------------------------------------------------*/
/*######-----<{ area }>------######*/
/* этот участок называется Шаблон области. Визуально строятся разделы сайта.
	В родителе задаётся: */

	grid-template-rows: 20px 30px 40px;
	grid-template-columns: 100px 200px 300px;
	grid-template-areas:	"header header header"	
												"main 	  .		 sidebar"/* точка означает пустая ячейка */
												"footer footer none";/*none ячейка просто ничего не будет выводить*/
/* каждому дочернему элементу раздаём метки: */
	grid-area: header;
	grid-area: main;
	/*...*/
/*
	И того: 
		В родителе размеры задаются через grid-template-columns/rows
		и шаблон через grid-template-areas. Можно попробовать
		в родителе избавиться от grid-template-columns/rows
		сократить через grid-template + размер строки и в конце записывается размер колонок
*/

	grid-template:	"header header header" 20px
									"main 	main	 sidebar" 30px
									"footer footer footer" 40px / 100px 200px 300px;/* после / 1я 2я 3я колонка*/

/*
	Плюсы:
	1. Вроде как даже удобно
	2. В html теги которые используют такой шаблон можно менять местами, визуально порядок не поменяется. 
		 Что такое сделать через числа нужно указывать каждому элементу начало и конец вот так: grid-area: 1 / 3 / 2 / 4;
	
	Минусы:
	1. При указании размеров колонок после слэша нельзя указать к примеру / 100px repeat(3, 1fr). repeat не работает.
	2. если захотеть установить 1й объект в колонку, а остальные оставить так же по строчно, то нужно размер объекта делить на колонки 
			obj1 300px / 3 = по 100 раскидываем строкам 
*/
	grid-template:	"obj1 p 	 p" 100px
									"obj1 r 	 r" 100px
									"obj1 g 	 g" 100px / 100px 200px 300px;/* после / 1я 2я 3я колонка*/


/*######-----<{ area проблемы }>------######*/
/* 
	1. Использовать сокращённую запись нужно с указанием размера иначе перебивает grid-template перебивает grid-template-columns/rows
 		 Просто шаблон через сокращённую запись grid-template, не выравнивает объекты. Если так же 1я колонка ограничена размером
		 то 2я и 3я колонка не одного размера. 3я больше 2й.
*/

	grid-template-columns: repeat(3, 1fr);/* так не выравнивает */
	grid-template: "logo header__phone sLink1"
								 "logo header__phone sLink2" ;
	grid-template-columns: repeat(3, 1fr);/*так выравнивает*/

/*
	2. В grid нельзя через шаблон задавать L образные фигуры
*/
	grid-template-columns: repeat(3, 1fr);
	grid-template-areas: "logo header__phone sLink1"
											 "logo header__phone sLink2" 
										   "logo logo sLink2" ; /* grid не поймёт L*/
										 

					

/*Запись может быть длинной*/
	grid-template-areas: "one one two two" 
											 "one one two two" 
											 "three three four four" 
											 "three three four four";


/*-------------------------------------------------------------------------------------*/
/*#######-------<{ МЕСТОПОЛОЖЕНИЕ }>--------#########*/
/*
	Задав родителю нужное число колонок и строк (сетку), есть свойства через которые в дочерних элементах
	можно задавать положение в этой сетке. Ориентиром должно выступать границы сетки а не сами колонки и строки.
	Позиции объектов через эти свойства можно задавать разными и для этого не требуется изменять html
*/
	grid-column-start: 1;	/*откуда начать*/
	grid-column-end: 2;	/*у начала какой колонки закончить*/
	grid-column: 1;/*т.к. занимает одну колонку то сократить запись можно так*/
	grid-column: 1 / 3;/*занимаем 2 колонки с 1 по начало 3й*/
	grid-column: 1 / -1;/*от качала и до самого конца. -1 это конец. Почему. можно писать и -2 и -3. 
		Предположим 3 колонки. т.к. ориентируемся не на колонки, а на линии, то у нас 4 линии. 
		1 по 2ю - 1 колонка, с 2 по 3ю - 2я колонка, с 3 по 4ю  3я колонка. 
		Если -1 это до конца, то -2 это до предпоследней линии, -3 до пред пред последней и т.д.
		Как мне кажется grid просто приписывает span: grid-column: 1 / -2;  	4 - 2 = 2 		grid-column: 1 /  span 2  
*/
/* span нужен если не хочется ориентироваться по линиям сетки, а хочется по колонкам и строкам.*/
	grid-column: 1 / span 3;/*с 1й линии 3 колонки*/
	grid-column: span 3 / 4;/*3 колонки до начала 4й линии*/
	grid-column: span 2;/* без начала и конца*/
	grid-row: span 2;
	grid-column-start: span 1;/*и так тоже можно записать*/

/* С row всё тож самое. Можно пойти дальше и записать ещё короче. Всё так же в дочернем элементе.*/
		
	grid-area: 1 / 1 / 4 / 2;/* row-start / column-start / row-end /column-end */
	grid-area: 1 / 1; /* row-start / column-start */


/* 
	Если использовать grid-area можно представлять себе например padding. его свойства работают по часовой стрелке, у area против часовой. 
	 grid-area: верх / лева / низ / право. или grid-area: верх / лева 

	 но... Не все браузеры понимают сокращённую запись. Автопрефих переведёт в 	grid-row/column


	Стоит заметить что задавая дочерним элементам положение в сетке они могут вытеснять элементы если для каких-то не хватило места они становятся
	за сеткой. Что бы контролировать пространство за сеткой нужно ставить родителю grid-auto-rows/column.
	Если всё рассчитано верно, то элементы просто при перемещении вытесняют элементы и они просто меняются местами.
*/

/*#######-------<{ ИМЕНА СТРОК И КОЛОНОК }>--------#########*/
	/* 9.12.2020 gulp-autoprefixer ругается на
1	 Autoprefixer не может использовать префикс отрицательных целых чисел.
2. Не понимает именованные колонки и строки, но именование через area понимает..
3. Autoprefixer добавляет префиксы grid-gap если оба grid-template-areas и grid-template-columns были определены.
	 Он также не может наследовать grid-gap через медиа-запросы.

	
*/
	grid-template-rows: [row1-s] 250px [row1-e row2-s] 400px[row2-e row3-s] 600px [row3-e];
	grid-template-columns: [col1-s] 250px [col1-e col2-s] 400px[col2-e col3-s] 600px [col3-e];
/*
		Зачем это надо? Можно сидеть и указывать дочерним элементам их положение по линиям сетки ну или всё же колонками через span(удобный способ как по мне)
		но есть и такой способ задавая имена и потом ссылаться на их в дочернем элементе.
*/
/* Все Примеры. без span Ориентироваться по линиям сетки разделяющих столбцы и строки */
/*.item1 */
		grid-row: row1-s / row2-e;
		grid-area: row1-s / col1-s / row2-e / col1-e;
		grid-area: 1 / 1;/*нач. 1строки / 1колонки(можно сократить) /(концовки сократил)*/

		grid-area: 2 span;/*2 строки*/

/*.item2 */
		grid-row: row1-s / row2-e;
		grid-area: row1-s / col2-s / row2-e / col2-e;
		grid-area: 1 / 2 / 3;/*нач. 1строки / 2колонки /кон. у 3й строки / (сократил)*/
		/*конечно же можно использовать grid-row*/
		grid-area: 2 span;/*2 строки*/
/*.item3 */
		grid-column-start: col3-s;
		grid-area: row2-s / col3-s;
		grid-area: 2 / 3;/*нач. 2строки / 3колонки*/

		grid-area: 1 span;/*1 строку*/
/*.item4 */
		grid-row-start: row1-s;
		grid-column-start: col3-s;
		grid-area: row1-s / col3-s;
		grid-area: 1 / 3;/* нач. 1строки / 3колонки*/

		grid-area: 1 span;/*1 строку*/
/*
	1. item1 и item2 не заданы колонки потому что они уже стоят в нужных колонках, я лишь сказал им что бы занимали по 2 строки.
		 Отсутствие привязанности колонок не привязывает элементы к позиции, если поменять места их в html, то они поменяют позицию
	2. Опять же даже через grid-area можно сокращать запись не указывая в каких то моментах конец или начало объектов если они уже располагаются
		 там где надо, это повлияет лишь на привязку к html. 
	3. Через span более понятное распределение элементов, тем более если они стоят уже в нужных местах.

	Как мне кажется не очень-то и удобно  задавать имена линиям, да и имена тут другие как 
	col1-start col1-end  row1-start row1-end и т.д., особо не напрашиваются.
*/


/* 3 колонки 2 строки. и свойство order. order - просто перемещает дочерние элементы по сетке, с учётом размера перемещаемого элемента. 
		Но что бы grid понимал где какой элемент в сетке, то нужно указывать всем элементам order задавая номер.
*/
/*.item1 */
		grid-row: 2 span;/*2 строки*/
		order: 1;
/*.item2 */
		grid-row: 2 span;/*2 строки*/
		order: 3;
/*.item3 */
		grid-row: 1 span;/*1 строку*/
		order: 2;
/*.item4 */
		grid-row: 1 span;/*1 строку*/
		order: 4;


/*
	ИТОГИ: 
		Самый удобный вариант это
		1. grid-template тож не важно сокращённый или нет и grid-column/row со span. Проще продумать сколько колонок и строк.
		2. grid-template-areas: шаблон; не важно сокращённый или нет и вызов в дочерних элементах grid-area: имя шаблона. 
		3. если приноровится то grid-area так же со span

		Самый как по мне не удобный это маркировать начало конец текстом
*/
/*наглядно*/
/*.parent*/
		grid-template: "logo phone sLink1" 
									 "logo phone sLink2" auto / 14rem 1fr 1fr;

		/*.item1*/
		grid-area: logo;
		/*.item2*/
		grid-area: phone;
		/*.item3*/
		grid-area: sLink1;
		/*.item4*/
		grid-area: sLink2;

/*против. span не указывается т.к. при перемещении в html элементов переместят их, а тут чистое сравнение */

/*.parent*/
		grid-template:  auto / 14rem  repeat(2, 1fr);

/*.item1*/
 		grid-area: 1 / 1 / 3 / 2;
/*.item2*/
		grid-area: 1 / 2 / 3 / 3;
/*.item3*/
  	grid-area: 1 / 3 / 2 / 4;
/*.item4*/
		grid-area: 2 / 3 / 3 / 4;

/*	Попробую сокращённый вариант со span использовать в вёрстке, практика покажет будут ли подвохи. */

/*#######-------<{ ПОЛЕЗНЫЕ ФИЧИ }>--------#########*/

/*т.к. строки auto, то можно провернуть ещё один трюк.*/
	grid-template:  auto  / repeat(3, 1fr);

/*.item1*/
		grid-row: span 2;
/*.item2*/
		grid-row: span 2;
/*.item3*/
		grid-row: span 1;
/*.item4*/
		grid-row: span 1;
/*
	Предположим у нас объекты одного класса, и вот тут при использовании span мы же не говорим где конкретно располагается объект,
	расположение контролируется html. И тогда зачем нам разделять классами?
	
	   <a class="social-link sLink1" href="#">
			<span class="social-name social-name--whatsapp">WhatsApp</span>
			...
		</a>
		<a class="social-link sLink2" href="#">
			<span class="social-name social-name--instagram">Instagram</span>
			...
		</a>
*/
/* т.к. строки автоматом 1й элемент 2 строки 2й 2 строки, а т.к. мы контролируем ситуацию нам надо минимум 2 элемента
   то 2 класса и получать по строке */
/*.item1*/
		grid-row: span 2;
/*.item2*/
		grid-row: span 2;
/*.social-link*/
		grid-row: span 1;

	/* Через grid-template-areas такой прикол не прокатит т.к. жёстко привязывает к месту.*/


/* ######------- ещё обрисую ситуацию ---> */
/*parent*/
		display: grid;
		grid-template: auto / repeat(4, 1fr);
/*item1 - 1 элемент*/
		grid-column: 1 / -1;/*занимает всю строку из 4х колонок*/
/*item2 - 1 элемент*/
		grid-column: 2 / 2 span; /* во 2й строке 2й и 3й столбик */
/*item3 - 4 элемента*/
		grid-column: 1 span; /* во 2й строке 2й и 3й столбик */
		
/* Надеемся 4 элемента раскидать по 3му ряду в каждую ячейку, но из-за того что во 2м ряде свободна ячейка 1й и 4й колонки,
   в 1ю почему-то не прыгает, а в 4ю элемент запрыгнет с 3го ряда, поэтому иногда нужно не забыть указать  */
		grid-row: 3;


/*----------------------------------------------------------*/
/*#######-------<{ ВЫРАВНИВАНИЕ КОНТЕНТА }>--------#########*/
	justify-content: start;/*управляет выравниванием сеткой целиком относительно родительского размера*/
	justify-items: start;/*управляет выравниванием контента в ячейках сетки относительно размера ячейки */
	justify-self: start;/*так же выравнивает контент в ячейке но индивидуально из дочернего элемента */

/*
	Что лучше задать контенту размер у себя, а колонки сделать одинаковыми или задать размер колонки ограничивая таким образом контент?
*/
	display: grid; 
	grid-template:  auto  / 140px  repeat(2, 1fr);/* а ещё оказывается достаточно 1 auto установить */
	justify-items: center;

/*
	Ну вот item1 140px. Сетка 140px, остальные элементы расположены в 2х одинаковых колонках. Примерно 1000 контент 
	1000 - 140 = 860px на 2 колонки по 430px на колонку и когда будет задано общий justify-items: center; элементы 2й и 3й колонки разделят
	430px / 2 = 215px - это центр для колонок. Мы то рассчитываем что колонка по середине займёт центр, а центр это 1000 / 2 = 500px.
	но если посчитать где сайчас стоит объект во 2й колонке, то ширина 1й + половина 2й колонки (140 + 215) = 355px. Далеко не середина.
*/

/*
	Есть 2 пути решения:
	1. Или задавать размер item и выравнивать контент в ячейках
*/
		display: grid; 
		grid-template:  auto  /  repeat(3, 1fr);
		justify-items: center;
/*.item*/
		max-width: 140px;


	/*
		2. Задавать grid-template любые размеры, то выравнивать как контент так и ячейки

		......
	*/



/*#######-------<{ НЮАНСЫ GRID }>--------#########*/


/*
	1. Поведение с объектами имеющие свои размеры. Картинки и svg. В svg присутствует width и height и viewBox.
			Здесь говориться о размере заданном через класс элементу. 

			<a class="header__social-link sLink1" href="#">
				<span class="header__social-name ">WhatsAp1p</span>
				<object class="header__social-icon >WhatsApp</object>
			</a>

	При попытке выравнивать посредством ограничения размера сеткой,
	
		.header__social-link
			grid-template-columns: auto 48px;//minmax(0, 48px) 
		
		.header__social-icon
			//max-width: 48px;
		

	элемент header__social-icon, у которого я убрал размер,	тупо вышел за пределы сетки и никакой minmax не помог.
	Возможно ли это что объектам имеющим свой размер, нужно его ограничивать непосредственно у себя в блоке, а не в сетке? 

		Да, но вот если в svg убирать размер width и height и оставлять только viewBox тогда можно и ограничивать сеткой.

	2. svg без свойств width и height на борту, но с ограничением в блоке используя max-width

		.header__social-link
			grid-auto-flow: column;
			justify-content: end;

		.header__social-icon
			max-width: 48px;

		Не имеет значения иконка имеет ли max-width или нет, если перевести grid в колонку через grid-auto-flow и попытаться прибить контент
		к той части где иконка, то она схлопнется. Можно или задать иконке просто width или создать grid-template-columns: auto 48px; 
	  При использовании flex такого не происходит. Он останавливается на максимальном размере. 
		


	И того: Что бы прибить элементы к краю
 .parent */

		  display: grid;
			grid-template-columns: auto 48px;
			align-items: center;
			justify-content: end;

/*
	 и можно не ограничивать в элементе размер
или
	.parent */
	  	display: flex;
			justify-content: flex-end;
			align-items: center;
/*.item */
			max-width: 48px;

/* 
или
	.patent */
			text-align: right;
			padding-top: 7px ;
/*.item */
			vertical-align: top;/*не обязательно можно и отрицательными значениями работать в translateY*/
			transform: translateY(9px);

/*
	Последний подход это подгонка элементов в ручную, а это изменение свойств в дальнейшем в медиа-запросах

Иногда есть моменты когда позиционирование проще использовать обычные свойства без flex и grid





*/
/*
	Стоит ли выравнивать текст используя display: inline-block и подгоняя padding-bottom/top или использовать grid и flex
  
*/





/*
	По умолчанию дочерние элементы растягивают свою ячейку на всю ширину и высоту заданную в родительском grid-template-columns/rows;
	Это происходит потому что по умолчанию в этой ячейке стоит
	justify-self: stretch;
	align-self: stretch;
*/
	
/*.item1*/
	margin: auto;/* выравнивает grid элемент по центру как по вертикали так по горизонтали*/




/* Нижняя полоса под текстом при использовании grid 
	Нужно научиться минимально использовать свойство position т.к. при изменении размера сайта
	зачастую всё пляшет и приходиться выходить за рамки блока налезая на другие блоки.
 Обычно выравнивают в псевдо элементах примерно таким способом:*/
 	display: block;
 	position: relative;
 	margin: 0 auto;/*воткнули по середине*/
	top: .9rem;/*отступили*/
/*ещё добавляют left, right или будет absolute. Это выходит за блок в grid да и просто блок.
	1й выход если полоса короче текстового блока.
::after*/
	display: block;
	margin: .9rem auto 0;
/*
	2й если полоса больше она растянет блок с текстом и хоть полоса по середине, текст будет слева
	достаточно выровнять текст в основном блоке
*/
	text-align: center;



/*------<{ Попытка использовать grid на всю секцию }>-----*/
/*
	Первые проблемы с которыми встречаемся при использовании grid на всей секции это то 
	что при попытке взять повторяющийся контент в другие секции он уже привязан к сетке и имеет свойства grid
	и придётся в другой секции тоже создавать такую же сетку.


	1. Можно попробовать обернуть элемент блоком на который будет влиять сетка и у элемента всё лишнее убрать,
		 но если элемент располагается в одних и тех же местах разных секциях, то правильней будет отвязать его совсем
		 от сетки и задать все необходимые свойства позиционирования и стиля (такие элементы нужно сразу вычислять и верстать,
		 после чего помещать в body препроцессора там где и container).
	2. Если элементы одинаковые, но имеют разное позиционирование в секциях, то элементу можно или не задавать позиционирование,
		 а отталкивать другими элементами.
	
	-------------------------------------------------------------------

	Варианты: 
	1. Много повторяющийся контент отвязывать от grid и проследить что бы класс этого контента 
		 получал все необходимые свойства и не наследовал то-что в другой секции мы не получим.
	2. На всём сайте во всех секциях иметь одинаковое кол-во колонок что бы при наследовании класса
		 свойства grid на этом блоке соответствовал. 
		 Есть пару пару вариантов и есть подводные камни, в обоих случаях сетку определяем
		 по повторяющимся элементам в ряд.(можно шлёпнуть 12 колонок чтоб наверняка) 
		 a) сетку создать одну и везде считать строки заполняя типа grid-row: 7 / 2span
				можно попробовать в area создать большой список всего сайта. Что будет если мы расставим
				элементы и понадобиться доп элемент воткнуть сбоку, придётся везде всё двигать или через 
				имена area или сидеть втыкать grid-column, grid-row.
		 b) создавать сетки в каждой секции, но одинаковое кол-во колонок, если придётся что-то
				изменить добавить колонку придётся те поправить только секцию и переопределить 
				блоки которые общие для сайта.

			Самый правильный подход это не пытаться совместить 1 секция 1 сетка, а разбивать на блоки и где надо 
			использовать сетку, а где надо flex. Нужно думать так: Затронет ли какой-то блок
			при добавлении элемента в то место над которым работаем
*/


/*-------------------------------------------------------------------------------------*/
/*#######-------<{ ЗАЗОРЫ }>--------#########*/
	grid-column-gap: 20px;/*расстояния между колонками*/
	grid-row-gap: 20px;/*расстояния между строками*/
	grid-gap: 20px 30px;/*сокр. вариант. grid-row-gap grid-column-gap*/
	grid-gap: 20px;

}

/*------------------------------------------------------------*/






/* Предположим 8 блоков item. Вариант опираться на контент. */

.box{
	display: grid;
	grid-gap: 10px;
	grid-template-columns: repeat(4, 1fr);
}
.item{
	color: aliceblue;
}
/* 
	4 блока уберутся в ряд 4 упадут вниз. Кол-во строк не указывали, так что строки из блоков формируются по себе.
	В 1м блоке будет куча текста 2,3,4 блок займут ту же высоту. Нижний ряд будет подстраиваться под свой блок.

	Можно выровнять блоки. Предположим во 2й строке блоки занимают свою высоту по контенту, но хочу что бы высота была как в 1й строке 
*/
.box{
	/*...*/
	grid-template-rows: repeat(2, 1fr); /*строки будут одинаковы. Если я не знаю сколько строк будет,то grid-auto-row*/
	grid-auto-rows: 1fr;/*по наибольшему блоку в какой-то строке. можно поиграть с minmax()*/
}

/*-------------------------------------------------------------------------------------*/
/*#######-------<{ МОБИЛЬНАЯ ВЁРСТКА }>--------#########*/

/*
	Есть ли разница начинать верстать сайт с мобильной версии и заканчивать ПК или верстать ПК версию и довёрстывать до мобильных версий?

	Если начинать с ПК версии, то создаём какую-то пачку свойств. При медиа-запросах на каждой точке перезаписываем одни и те же свойства,
	скрываем, изменяем положение.

	Если начинать верстать с мобильной версии, то начинаем с малого и по мере необходимости добавляем код на ступенях и где-то лишь изменяем размер
	на самом при такой вёрстке кода будет меньше.
*/



/*
  autoprefixer в grid имеет баг при использовании repeat(3, 1fr) в grid-template-columns;
  autoprefixer не работает с justify-content и так же рекомендует использовать 
  justify-self на дочернем, вместо родительского justify-items
*/