body{
		/*#######---------<{ Grid свойства и методы }>--------########*/

	/*
   auto-fill - автоматическое заполнение элементами (заданного размера) пока есть место в контейнере 
                работает как flex-wrap: wrap.Если minmax(100px, 200px) статичные размеры, auto-fill умещает
                только по max значению. Если задать max в единице fr minmax(100px, 1fr), то auto-fill умещает
                в минимальном размере и держит их в этом размере
               Если быть точней.
               Контейнер делиться на равные части заданного размера. 
                Сетка создаётся по факту (размера контейнера / на размер элемента). Если установлен minmax и его max значение 
                статическое, то сетка (размера контейнера / на макс размер элемента), если в единице fr:  minmax(100px, 1fr), 
                то сетка будет: (размера контейнера / на минимальное значение.) По мере уменьшения контейнера
                уничтожение лишних секций сетки. Как контейнер сталкивается с реальными элементами происходит перенос flex-wrap: wrap.
                элементы используют max значение 1fr до тех пор пока auto-fill делает перерасчёт (контейнер / на минимальное значение элемента)
                То есть если размер контейнера позволяет 2м элементам в минимальном размере находиться на одной линии flex-wrap: wrap 
                не произойдёт.
  
        
   auto-fit -  Визуально похоже что работает так же как auto-fill, до момента использования fr единицы в minmax(100px, 1fr).
               На самом деле работает это так. Сетка создаётся по факту имеющихся элементов и их размеров. То есть
               (кол-во эл. * максимальный размер). При уменьшении контейнер если он встречается с сеткой то сетка (размера контейнера / на макс размер элемента),
               Из за того что серка работает по факту кол-ва элементов то minmax(100px, 1fr) это сетка (контейнер /  max размер), а max 
               размер (контейнер / кол-во эл.) и того (контейнер / (контейнер / кол-во эл.))

               Всё что нужно вкратце знать: При использовании единицы fr в minmax(100px, 1fr),
                  auto-fill держит элементы в min значении, auto-fit в max значении.  У обоих flex-wrap: wrap срабатывает при min значении. 
            
   minmax() - При изменении размера контейнера, если элемент не влазит будет изменяется до минимального значения.
            используется для адаптива. Используя в связке с auto-fill, auto-fill будет пытаться умещать по максимальному размеру элемента
						будто минимально размера нет. auto-fit так же отработает. 
						
		
	Единица fr(фракции) 3fr 1fr 1fr. При общей ширине в 100px
	1я колонка будет занимать 3fr из 5 возможных
	100 / 3+1+1 = 20px (1fr) значит 60px 1я колонка
   
   	repeat(кол-во раз, размер); повторить 
    repeat( 2, 50px ); - 50px 50px   
		repeat( 2, 50px 70px ); - 50px 70px 50px 70px
		
	*/

	/*#######-------<{ ОПРЕДЕЛЕНИЕ СЕТКИ и ЕЁ РАЗМЕРОВ }>--------#########*/
/*
	1. дочернему элементу можно, даже я б сказал не нужно задавать ширину и высоту, т.к. всё задаётся через родителя
			в grid-template-rows и columns.
			По умолчанию колонки подстраиваются, под самую высокую расположенную в именно в одном ряду. Пример ниже.
	2. Если каждую строку выравниваем по контенту наибольшей колонки, то смысла записывать 
		grid-auto-row: min(auto) или minmax(100px, auto) вообщем auto уже делает своё дело
*/
	grid-template-rows: repeat();	/*кол-во строк и их высота*/
	grid-template-columns: 1fr 2fr;	/* ко-во колонок и их высота*/
	grid-template: grid-template-rows / grid-template-columns;
	/*отвечает так же и за grid-template-areas*/
	/*grid-template-... нужна когда знаем сколько колонок и строк. grid-auto-... когда не знаем и это указывать не нужно, но нужно подстроить размер.
		вообщем-то с сервера получать товары и строить так блоки самое то
	*/
	grid-auto-rows: minmax(100px, auto);
	


	grid-template-columns: repeat(auto-fit, minmax(0, max-content));
	justify-content: space-between;


/*--<{ area }>--*/

	grid-template-areas:
	/*визуальное составление сетки в род. блоке*/
	"header header"
	/* этот участок называется Шаблон области*/
	"main sidebar"
	"footer footer";

	/* сокращённая через grid-template + можно размер задать */
	grid-template:
	"header header" 25px
	/*то есть grid-template-rows для каждого ряда */
	"main sidebar" 30px "footer footer" 40px / 50px;


	/*каждому дочернему элементу нужно дать имя*/
	grid-area: header;
	grid-area: main;
	grid-area: sidebar;
	grid-area: footer;




/*#######-------<{ МЕСТОПОЛОЖЕНИЕ }>--------#########*/
	grid-column-start: 1;	/*откуда начать*/
	grid-column-end: 2;	/*у начала какой колонки закончить*/
	grid-column: 1;/*т.к. занимает одну колонку то сократить запись можно так*/
	grid-column: 1 / 3;/*занимаем 2 колонки с 1 по начало 3й*/
	grid-column: 1 / -1;/*от качала и до самого конца. -1 это конец*/
	/*с row всё тож самое. Можно ещё короче: */
	grid-area: 1 / 1 / 4 / 2;/*grid-row-start / grid-column-start / grid-row-end /grid-column-end */
	/*
  Ключевое слово span - указывается для определения не откуда - докуда, а
  откуда и сколько или сколько и докуда. Комбинаций строк и колонок куча.
  */
	grid-column: 1 / span 3;/*с 1й и 3 колонки*/
	grid-column: span 3 / 4;/*3 колонки до начала 3й*/
	

	/*
  Так же можно считать строки с конца использовав отрицательные значения. 
  Но мне пожалуй такое не нужно
  */

/*#######-------<{ ЗАЗОРЫ }>--------#########*/
	grid-column-gap: 20px;/*расстояния между колонками*/
	grid-row-gap: 20px;/*расстояния между строками*/
	grid-gap: 20px 30px;/*сокр. вариант. grid-row-gap grid-column-gap*/
	grid-gap: 20px;

}

/*------------------------------------------------------------*/

/* Предположим 8 блоков item. Вариант опираться на контент. */

.box{
	display: grid;
	grid-gap: 10px;
	grid-template-columns: repeat(4, 1fr);
}
.item{
	color: aliceblue;
}
/* 
	4 блока уберутся в ряд 4 упадут вниз. Кол-во строк не указывали, так что строки из блоков формируются по себе.
	В 1м блоке будет куча текста 2,3,4 блок займут ту же высоту. Нижний ряд будет подстраиваться под свой блок.

	Можно выровнять блоки. Предположим во 2й строке блоки занимают свою высоту по контенту, но хочу что бы высота была как в 1й строке 
*/
.box{
	/*...*/
	grid-template-rows: repeat(2, 1fr); /*строки будут одинаковы. Если я не знаю сколько строк будет,то grid-auto-row*/
	grid-auto-rows: 1fr;/*по наибольшему блоку в какой-то строке. можно поиграть с minmax()*/
}