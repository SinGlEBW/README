body{
		/*#######---------<{ Grid свойства и методы }>--------########*/

	/*
   auto-fill - автоматическое заполнение элементами (заданного размера) пока есть место в контейнере 
                работает как flex-wrap: wrap.Если minmax(100px, 200px) и статичные размеры auto-fill умещает
                только по max значению. Если задать max в единице fr minmax(100px, 1fr), то auto-fill умещает
                в минимальном размере и держит их в этом размере
               Если быть точней.
               Контейнер делиться на равные части заданного размера. 
                Сетка создаётся по факту (размера контейнера / на размер элемента). Если установлен minmax и его max значение 
                статическое, то сетка (размера контейнера / на макс размер элемента), если в единице fr:  minmax(100px, 1fr), 
                то сетка будет: (размера контейнера / на минимальное значение.) По мере уменьшения контейнера
                уничтожение лишних секций сетки. Как контейнер сталкивается с реальными элементами происходит перенос flex-wrap: wrap.
                элементы используют max значение 1fr до тех пор пока auto-fill делает перерасчёт (контейнер / на минимальное значение элемента)
                То есть если размер контейнера позволяет 2м элементам в минимальном размере находиться на одной линии flex-wrap: wrap 
                не произойдёт.
  
        
   auto-fit -  Визуально похоже что работает так же как auto-fill, до момента использования fr единице в minmax(100px, 1fr).
               На самом деле работает это так. Сетка создаётся по факту имеющихся элементов и их размеров. То есть
               (кол-во эл. * максимальный размер). При уменьшении если контейнер встречается с сеткой то сетка (размера контейнера / на макс размер элемента),
               Из за того что серка работает по факту кол-ва элементов то minmax(100px, 1fr) это сетка (контейнер /  max размер), а max 
               размер (контейнер / кол-во эл.) и того (контейнер / (контейнер / кол-во эл.))

               Всё что нужно вкратце знать: При использовании единицы fr в minmax(100px, 1fr),
                  auto-fill держит элементы в min значении, auto-fit в max значении.  У обоих flex-wrap: wrap срабатывает при min значении. 
            
   minmax() - При изменении размера контейнера, если элемент не влазит будет изменяется до минимального значения.
            используется для адаптива. Используя в связке с auto-fill, auto-fill будет пытаться умещать по максимальному размеру элемента
						будто минимально размера нет. auto-fit так же отработает. 
						
		
	Единица fr(фракции) 3fr 1fr 1fr. При общей ширине в 100px
	1я колонка будет занимать 3fr из 5 возможных
	100 / 3+1+1 = 20px (1fr) значит 60px 1я колонка
   
   	repeat(кол-во раз, размер); повторить 
    repeat( 2, 50px ); - 50px 50px   
		repeat( 2, 50px 70px ); - 50px 70px 50px 70px
		
	*/

	/*#######-------<{ ОПРЕДЕЛЕНИЕ СЕТКИ и ЕЁ РАЗМЕРОВ }>--------#########*/

	grid-template-rows: repeat();	/*кол-во строк и их высота*/
	grid-template-columns: 1fr 2fr;	/* ко-во колонок и их высота*/
	grid-template: grid-template-rows / grid-template-columns;
	/*отвечает так же и за grid-template-areas*/
	grid-auto-rows: 100px;
	/*высота по ум. с колонкой тож самое*/


	grid-template-columns: repeat(auto-fit, minmax(0, max-content));
	justify-content: space-between;

	/*каждому дочернему элементу нужно дать имя*/
	grid-area: header;
	grid-area: main;
	grid-area: sidebar;
	grid-area: footer;

	grid-template-areas:
		/*визуальное составление сетки в род. блоке*/
		"header header"
		/* этот участок называется Шаблон области*/
		"main sidebar"
		"footer footer";
	/*как сказано выше сокращённая grid-template может так же + */
	grid-template:
		"header header"25px
		/*то есть grid-template-rows для каждого ряда */
		"main sidebar"30px "footer footer"40px / 50px;


/*#######-------<{ МЕСТОПОЛОЖЕНИЕ }>--------#########*/
	grid-column-start: 1;	/*откуда начать*/
	grid-column-end: 2;	/*у начала какой колонки закончить*/
	grid-column: 1;/*т.к. занимает одну колонку то сократить запись можно так*/
	grid-column: 1 / 3;/*занимаем 2 колонки с 1 по начало 3й*/
	grid-column: 1 / -1;/*от качала и до самого конца. -1 это конец*/
	/*с row всё тож самое. Можно ещё короче: */
	grid-area: 1 / 1 / 4 / 2;/*grid-row-start / grid-column-start / grid-row-end /grid-column-end */
	/*
  Ключевое слово span - указывается для определения не откуда - докуда, а
  откуда и сколько или сколько и докуда. Комбинаций строк и колонок куча.
  */
	grid-column: 1 / span 3;/*с 1й и 3 колонки*/
	grid-column: span 3 / 4;/*3 колонки до начала 3й*/
	

	/*
  Так же можно считать строки с конца использовав отрицательные значения. 
  Но мне пожалуй такое не нужно
  */

/*#######-------<{ ЗАЗОРЫ }>--------#########*/
	grid-column-gap: 20px;/*расстояния между колонками*/
	grid-row-gap: 20px;/*расстояния между строками*/
	grid-gap: 20px 30px;/*сокр. вариант. grid-row-gap grid-column-gap*/
	grid-gap: 20px;

}

/*------------------------------------------------------------*/