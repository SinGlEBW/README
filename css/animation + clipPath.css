/*#########----<{ Анимации }>----#########*/
.myClass{
	opacity: 0;
	transition: opacity 1s ease-in-out;
}
/*
	В классическом виде hover эффекты работают одинаково в обе стороны с одной и той же скоростью.
	Можно это обойти сбросив transition прямо в нём. 
		Появиться быстро, пропадать будет медленно т.к. свойства перебивают свойства основного блока
*/
.myClass:hover{
	transition: opacity 0s ease-in-out;
	opacity: 1;
}


/*
	Конструкция keyframes это лишь шаблон кадров который вызывается через animation в
	каком-то блоке
*/
@keyframes nameAn{
/*Позиции кадров  записываются или так*/
	0%{}
	50%{}
	100%{}
/*или в 2 позиции вот так*/
	to{}
	from{}
	/**/
}


div{
	/*сокращённая запись. При желании сокр.запись может принимать через запятую дополнительный keyframes*/
	animation: nameAn duration timing-function delay iteration-count direction fill-mode;
	/*все свойства могут принимать несколько значений через запятую*/
	animation-name: nameAn;
	animation-duration: 0s;/*Время проигрывания. или s или ms*/
	animation-timing-function: linear;/*вид анимации 
		ручной переход cubic-bezier(x1, y1, x2, y2); Кривая безье. Движение скорость движения рассматривается
		по оси x. Если рисует линию в верх по y то по x как таковой движения минимально отсюда и скорость 
	
	*/
	animation-delay: 1s; /*Задержка анимации*/
	animation-iteration-count: 1;/*Кол-во повторов. infinite-бесконечно*/
	animation-direction: normal;/*направление по ум. normal, reverse, alternate-от начала к концу, alternate-reverse с конца в начало */
	
	animation-play-state: running; /*в сокращённой записи вроде нет. Можно задать поведение при наведении
																		мыши останавливать paused, none - возвращать на место*/
	animation-fill-mode: both; /*	К элементу в конце анимации применяется: по ум none, forwards стиль последнего кадра, backwards стиль первого кадра, both оба стиля*/
	
}



/*-----------------------------------------------------------------------------------------------------------*/
/*#########----<{ clip-path css }>----#########*/
/* 
  clip устарело, замена clip-path.
   Понятие "вырезать" - это сохранить фигуру, остальное отрезав
   clip-path: url(#myCP); - можно к div подключить заготовленный svg clipPath и это потребуется если нужно создать фигуру с плавными путями 
                            на основе кривых Безье, потому что в css метода path нет. Так что можно сразу всё делать в svg.
                            Можно конечно сойти сума и там где нужны плавные изгибы вырезать кучу кругов и элепсов накладывая друг на друга, но пожалуй это не то что надо.
  clip-path: basic-shape, [geometry-box] - не обязательное и не реализованные свойства;                     
													fill-box; stroke-box; view-box; margin-box; border-box; padding-box; content-box;
													
  методы. Из называют basic-shape - Основные формы.
    inset(20px 30px 10px 15px); - отсекает стороны. значения как и везде по часовой и не обязательно. Замена rect() т.к. он ни где не работает
    circle(50px at 100px 100px); - сохранить круг в 50px по координатам 100px на 100px по X и Y относительно элемента и центра круга 
                                   после at можно использовать center или сразу 2 left top, опустить всё после at выравнивание будет по центру                        
    ellipse(60px 30px at 75px 130px); - ширина высота и где оставить ellipse
    polygon(50px 50px, 100px 100px, 50px 150px); - сохраняет фигуру минимум 3 точки.

  ВАЖНО: 1. Что бы анимация заработала нужно соблюдать одинаковое количество вершин.
						 Если надо заполниться 0% 0% иначе анимация работать не будет 
				 2. polygon строиться по часовой стрелке и когда преобразуем одну фигуру в другую 
							нужно правильно понимать какую точку мы ходим переносить из одной точки в другую
							иначе анимация может выглядеть не так как мы ожидали	
				 3. При обрезке изображения через css нужно проследить что контейнер такого же размера как и изображение
				    т.к. обрезка совершается относительно контейнера и clipPathUnits="objectBoundingBox" нету что бы перевести относительно изображения 	 
*/
.el{
  background: url('../img/image1.jpg') center /cover;
  transition: clip-path 2s cubic-bezier(1, 0, 0, 1);
  clip-path: polygon(0% 0%, 0% 100%, 100% 100%, 0% 0%, 0% 0%);
  width: 700px;
  height: 500px;
}
.el:hover{
  clip-path: polygon(26% 25%, 100% 0%, 100% 100%, 20% 50%, 70% 40%);
}

/*#########----<{ mack css }>----#########*/
/*
	Можно подключить прямо svg файл.
	Про mask на css на 2020 можно позабыть, работает только в firefox, на других браузерах даже префикс не везде спасает.
*/
.el{
	mask: url(mask.svg);
}
/* Маски делятся на типы
	  mask-type: luminance; // white = прозрачный, grays = полупрозрачный, black = не прозрачный 
		mask-type: alpha; // прозрачные области изображения пропускают изображение, иначе нет
*/