/*eslint-disable*/
/*--чистый NodeJS-- https://habr.com/ru/post/479048/*/

/*
  Объекты запрос и ответ являются потоками.
*/
let readStream = fs.createReadStream(путь_к_файлу); // создаёт прочтение потока

let readableStream = fs.createReadStream("hello.txt", "utf8");
let writeableStream = fs.createWriteStream("some2.txt");
 
readableStream.pipe(writeableStream);//проток чтения будет прочитан и передан в поток записи который передан через pipe

readStream.on("open", function () {
  readStream.pipe(res); //т.к. res это поток, а pipe работает с данными Stream то передаёт поток в поток объекта ответа
});
readStream.on("error", function (err) {
  res.end(err); //в случаях ошибок упадут сюда, после чего закроем закроем соединение
});

//старый вариант
const file = fs.readFileSync("path to file"); //не Stream

res.send(file);

/*
Разница лишь в том, что в первом случае мы загружаем часть файла и отправляем ее, 
таким образом, не загружая оперативную память сервера. Во втором случае мы сразу загружаем файл 
целиком в оперативную память и только потом отправляем.
*/

//Создание потока
const { Readable } = require('stream');

// 1 - Используя конструктор
const myReadable1 = new Readable(opt);

// 2 - Наследуя класс 
class myReadable2 extends Readable {
  constructor(opt) {
    super(opt);
  }
}
opt // принимает параметры
let read = new myReadable2({ highWaterMark })//highWaterMark — это максимальное количество.по умолчанию 16кб


/*
  О потоках и процессах.

    После запуска приложения система создаёт объект Процесса который хранит в оперативной памяти. 
  Процесс имеет кучу информации одна из которых исполняемый файл. Как я понимаю скорей всего всё 
  содержимое исполняемого главного файла помещается в функцию main которая и запускается процессором.
  (Скорей всего на языке c++ и ему подобных имеющих функцию main в файле это работает так же просто отрабатывает
  main который оборачивает код файла, отрабатывает сначала всё что вне функции main в файле и вызывается сама функция main)
  
  При запуске main чтение файла в синхронном режиме (последовательно, пока не выполниться один код к другому не переходит)
  работает в одном потоке. В таком режиме когда встречается какая-то функция которая может долго работать, блокирует 
  основное выполнение кода (основной поток) пока функция не вернёт результат или просто не отработает основной код дальше 
  не может выполняться. Это хорошо если нам нужен этот результат, им мы воспользуемся в основном потоке, но плохо 
  если мы не ожидаем от функции результата, а программа стоит. 
  
    Неплохо было бы заставить её работать в параллельном потоке, то есть в асинхронном режиме. Как я понимаю это работает 
    так:
      В 1 процессе(в запущенном приложении) в главном потоке, долгоиграющие функции будут обрабатываться на разных ядрах 
      с созданным для них новым потоком и тем самым сколько ядер, столько параллельно функций может отработать в своём потоке.
    
    В синхронном же варианте в 1 процессе 1 поток.
  
  Всё что касается кучки запущенных процессов на компе это лишь означает то что на 4х ядерном процессоре может работать 
  в чистом виде 4 одновременно процесса(программы), остальные запущенные процессы так же раскидываются на 4 ядра, но мы не работаем
  во всех одновременно программах нагружая их на 100%, поэтому ядра не нагружены и готовы быстро переключаются между процессами 
  по мере своей нагруженности. Какое-то ядро занято одно-поточным приложением которое использует в данный момент пользователь, остальные 
  ядра по мере важности и откликов других процессов ими занимаются. Если клиент использует приложение с асинхронным выполнением 
  (требующем параллельного потока) ядра так же откликаются и создают потоки.
  

    
  



  О Процессорах.





Пересмотреть нижеописанное
  Главный поток это функция из файла файл который будет обрабатывать процессор 
  1. Процессор состоит из ядер которые снабжены транзисторами при переключении которых строиться логические 
     цепочки электрических сигналов, кеш памяти хранит набор инструкций указывающих что делать с этим сигналом.
     L1, l2, l3 ...  Они быстрей чем оперативная память в которой так же можно хранить эти инструкции.
     
     Задача на ядре это процесс или правильно называть потоки(Thread - нить) выполнения кода.
     То есть 1 запущенная задача выполняется на каком-то ядре и эта задача имеет как минимум 1 главный 
     поток кода который нужно выполнять. В случае каких-то взаимодействий с этой программой отрабатывает 
     логика в главном потоке. В нём по-любому встретятся функции которые будут выполняться параллельно главному потоку
     создавая ещё поток выполнения, пока главный поток ожидает результата от функции. Но в целом это один последовательный поток.


     1 ядро содержит как минимум главный поток в котором 


  2. Одно-ядерный процессор не может выполнять одновременно задачи. Он переключается между ними очень быстро.
  3. Переключение над задачами это какое-то время простоя процессора. Чем больше задач(процессов) на одном ядре тем
     больше переключений и меньше времени уделяемого задачам.
  4. Увеличив частоту увеличиваем скорость переключения между задачами за 1 секунду, но не рентабельно
     одним ядром выполнять много процессов т.к. каждый процесс в ядре хочет использовать его кеш память  
     и если задач много, кеша не хватает и приходится хранить данные задачи в оперативной памяти.

     До какого-то времени когда ядро переключалось на задачу он отдавал все ресурсы на эту задачу.
     Задача как обычно делает запрос к данным в оперативной памяти и может и на жёсткий диск и пока задача ждёт эти данные,
     ядро сидя на этой задаче так же ждёт. Если это ожидание продолжается довольно долго такую операцию называют блокирующей
     т.к. остальные процессы ожидают выполнения своих потоков. Как только поток процесса выполнил свою потребность в
    данный момент времени, ядро переключится на другой процесс с потоком.
    
  5. Чем хороши многоядерные процессоры тем что задачи можно распределить по ядрам которые так же будут 
     переключатся между своими задачами, но уже их не так много на 1 ядро будет и кеш памяти каждого ядра уже 
     в какой-то мере некоторым задачам будет хватать.
  6. Каждая задача выполняет главный(main) поток кода. Чтения потока обычно движется сверху вниз.
     И если требуется создаётся ответвление потока например когда встречается функция. Пока она выполняется
     главный поток ждёт результата.  
      
  7. Ка было сказано: "пока поток ожидает данных ядро висит". Придумали ядро разбивать на блоки и прозвали это гипер-трейдинг.
     Hyper Threading(гипер-поточность) это технология которая создаёт виртуальные ядра в ядре. По сути ядро делит ресурсы для потоков.
     Если блок в ядре простаивает с задачей например 20% занимает ресурсов ядра, то другие потоки используют оставшиеся ресурсы. 

   
  Процесс - содержит информацию о потоке, так же процесс хранит информацию о себе
  У каждого потока есть память Stack в которой храниться выполнение потока
  Каждый поток знает к какому процессу(задаче) он относиться




*/