
/*########-------<{ свойства EVENT }>--------##########
События работают так:

1. Событие на родительском элементе, будет отрабатывать даже при клике на любой вложенности дочерних элементов.
2. Ещё одна ситуация, если на дочернем элементе событие напр. "click" и на родительском и может даже и на предке такое-же,
   то кликнув на дочерний элемент, отработает и на родителе. Остановить это безумие нужно дочернему 
   указать e.stopPropagation(). Самый глубокий(внутренний дочерний) - называется целевым.

*/
// Событие focus не всплывает.
change//отрабатывает при потере фокуса. в React отрабатывает вроде как при вводе
focus//при фокусировке
input//отрабатывает после каждого ввода. preventDefault() там – будет уже слишком поздно
cut//вырезании
copy//копирование
paste//вставка

/* Для input есть метод который выделяет текст  */
input.setSelectionRange(2, 5);//откуда покуда





ev.currentTarget//где висит обработчик
ev.relatedTarget || fromElement//mouseover(над) - откуда пришла мышь, mouseout(ушёл) - на который курсор перешёл
ev.target || toElement//mouseover(над) - куда пришла, mouseout(ушёл) -  с которого курсор ушёл.
ev.bubbling //<bool указывает на всплытие 
ev.capturing //<bool указывает на погружение(перехват). События опускаются вниз
ev.defaultPrevented// возвращает bool если был вызван в событии ev.preventDefault()

ev.movementX // - свойство сохраняет разницу значения предыдущего события mousemove и нового. 1 или -1



ev.stopPropagation()//остановит всплытие. если есть обработчик события, на дочернем элементе, и второй обработчик того же события на родителем.
addEventListener(событие,callback, option);
//если опции были указаны в событии, то при удалении события тоже их нужно указывать в removeEventListener 
option = {
  capture: bool,//
  once: bool,//отработать 1 раз.
  passive: bool,//
}



/*########-------<{ События }>--------########## */
ЗАПОМНИТЬ: 
mouseenter (над)/mouseleave (ушёл)// не всплывают в отличие от
mouseover (над)/mouseout (ушёл)//всплывают.отрабатывают когда элемент передвигается по дочерним элементам 


window.scroll(x, y)/scrollTo(x, y);//прокручивает от 0 до значения
window.scrollBy(x, y);//каждый раз когда отрабатывает прибавляет к предыдущему значению

//спрятать скролл и скрола вниз не будет 
document.body.style.overflow = "hidden";

Wheel//Событие колеса мыши срабатывает раньше чем scroll.overflow:hidden никак не препятствует обработке колеса мыши
scroll//Событие передвижения полоски скрола в окне
//вырубить скрол при popup
window.addEventListener('wheel', (e) =>{
  e.preventDefault()
}, { passive: false });

/*#####--------<{ События для телефонов }>------#######*/
"touchstart" /* Получаем TouchEvent. Не сработает при клике мыши, за то клик мыши сработает и на компе на телефоне.
В TouchEvent есть дополнительный массив touches. Видимо кол-во одновременных нажатий
  0: 
    clientX: 410.1265869140625
    clientY: 259.0506286621094
    force: 1
    identifier: 0
    pageX: 410.1265869140625
    pageY: 259.0506286621094
    radiusX: 11.5
    radiusY: 11.5
    rotationAngle: 0
    screenX: 796
    screenY: 476
    target: button
*/

