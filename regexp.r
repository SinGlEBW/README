.	 - любой символ за исключением символов новой строки: \n, \r, \u2028 или \u2029
\d - цифры в базовом латинском алфавите. Эквивалентен набору символов [0-9].
\D - любой символ кроме цифр в базовом латинском алфавите [^0-9].
\w - Буквы или цыфры [A-Za-z0-9_]
\b - граница слова.  A\bB по какую сторону напишу там и будет смотреть.
\B - не начало и не конец. Ищем текст в середине слова. Русский текст ищет полностью. Подозреваю это из-за
^ - начало строки
$ - конец строки

  Кванторы - это то что приписываеться к искомым значениям. Сами по себе они не ставятся. 
  Используються в конструкциях: Жадные - ищут много, Ленивые и Липкие
* - ноль или больше
+ - один или больше
? - ноль или один. Если он вставлен после другова квантификатора, то режим жадный сменяеться на ленивый.
                   можно установить своё кол-во 
[0-9] - диаппазон перечислений

Оператор условия ИЛИ — | или []
[abc] - вместо оператора ИЛИ. a | b | c, но только для одного символа 
А(слово1|слово2) - после "А" должно быть "слово1" или "слово2"

А{2} - буква А ровно 2. ААААБ - тоже подходит. 
А{3,10} - диаппазон от 3 до 10 включительно предыдущего символа

----------------------------------------------------------------------------------------------------------------------

[a-z]*(?=__|\w*[^_-])

\w+(?=__)


Примеры
  a(bc)* - ищем "a" или вместе с конструкцией "bc", или без неё
  a(bc) - ищем "a" с конструкцией "bc". Впринципе искать abc это тож самое
  a(bc){2,5} - ищем "a" с конструкцией "bc", от 2 до 5 раз
  a[bc] - ищем "ab" или "aс"
-------------------------------------------------------------
данные ищутся перед конструкцими условий ...(?= ) или ...(?! )

Lookahead(Позитивная Опережающая проверка) 
  X(?=Y) - найти X при условии что за ним следует Y

  [T|t]he(?=\sfat) - ищет The или the перед \s-пробел fat. (Граница стоит перед пробелом)
  \w+(?=__) - ищу любое кол-во букв перед __

Lookahead(Негативная опережающая проверка)
  X(?!Y) - найти X при условии что за ним НЕ следует Y

  [T|t]he(?!\sfat) - ищет где угодно но не перед \sfat

--------------------------------------------------------------
данные ищутся после условий (?<= )... или (?<! )...

Lookbehind(Позитивная ретроспективная) 
  (?<=Y)X - ищет совпадение с X при условии, что перед ним ЕСТЬ Y.

  (?<=[T|t]he\s)(fat|mat) - все fat и mat после The или the 

Lookbehind(Негативная ретроспективная)
  (?<!Y)X - ищет совпадение с X при условии, что перед ним НЕТ Y

  (?<![T|t]he\s)(cat) - ищет все cat которые не идут после The или the

--------------------------------------------------------------









Жадные выражения ( * )
  (.*at) - The fat cat sat on the mat. - Любые символы, от 0 и больше, заканчиваються слова на at
  Такой подход будет выделит всю строку до последнего слова заканчивающегося на at

Ленивые выражения ( *? )
  (.*?at) - выделит только ту часть строки которая входит до первых встречных буукв at

-------------------------------------------------------------------------------------------------------------------------------

ОТРИЦАНИЕ 
  [^а-я] - ^ отрицание. Ищем что угодно, кроме диапазона букв
  ^(?!index\.html$).+   Ищет любое слово кроме index.html. ТО ЧТО ЧАСТО ТРЕБУЕТСЯ

  d(?=r) - ищем "d" после которой стоит буква r, но r выделять нам не надо. 
  a(?!bc) - ищем символ "a", но без конструкции bc
  a(?!bc)* - немного странно и смысла в этом нетпрост для понимания кину. ищем сивол "a" и без конструкции bc,
            но из-за * таких условий или 0 или более. По факту мы найдём 1й символ a даже если далее bc. Короче противоречие условию(?!)
  (?<=r)d - нам нужна та буква "d" перед которой стоит буква r, но r выделять нам не надо. 
  d(?!r) - нам нужна та буква "d" после которой не стоит r
  (?<!r)d - нам нужна та буква "d" перед которой не стоит r

 
----------------------------------------------------------------------------------------------------------------------------------
Жадные квантификаторы
Пример Есть строка <div> simple div</div> test <options> нужно выделить только теги.
Пробуем искать. 
<.+> - результат такого поиска будет выделена вся строка т.к. .+ это любой символ от 1 и выше, поэтому
остановки на первых встречных символах ">" не будет. Захвачена будет вся строка. Потом движок понимает что есть ещё в условии
найти > он отступает назад до последнего искомого символа >.

Что бы движку не пришлось поглощать всю строку потом возвращаться назад нужно указать ему ленивый режим.
<.+?> - ? переходит в другой режим при использовании с другим квантификатором. . ищет символ, далее +?
переключаеться на поиск символа >, такого не находит снова возвращаеться к выполнению условия .+, потом опять проверяет есть ли 
символ > и т.д
-------------------------------------------------------------------------------------------------------------------------------

Ссылки, не очень полезно
() - в скобках указывается группа которую нужно найти, у группы есть понятие Ссылка на элемент.
Каждая такая ссылка для каждой группы нумеруеться. ()\1 ()\2 ()\3. Самое интересное что эту ссылку можно перемещать. Удобно впринципе если разобраться.
Пример: 
Молокозавод - найти оло. Понятно что можно ввести (оло). Просто пример не совсем удачный, но возможность имеет большой потенциал.
([мо])([лрд])\1 - найти [м или о] далее найти [л или р или д] т.к. 1я группа находит "о", то мы имеет ссылку 1й группы и кидаем её куда нам надо.
(букв накидал прост для приличия)

 Есть понятие Увеличить результат на 1
(a)\1 - найти конкретно 2 aa, (a)\1\1 - 3 aaa (тоже самое (a){3} или (aaa))


-------------------------------------------------------------------------------------------------------------------------------
РЕШЕНИЯ НА ПРАКТИКЕ
  (?<=token:\s*['"])(.*\b)  - найти всё что после token: возможно пробелы '||" эту строку получу до конца текста без '||"
  /[A-Z]/.test('S'); //true  s- false. Метод test ищет возвращает bool если находит что-то 
-------------------------------------------------------------------------------------------------------------------------------